# =============================================================================
# COMPLETE KUBERNETES PRODUCTION TEMPLATE - 25 RESOURCES
# =============================================================================
# This template provides a comprehensive production-ready deployment stack
# including security, monitoring, service mesh, and operational components
# =============================================================================

# =============================================================================
# CORE INFRASTRUCTURE (Resources 1-9)
# =============================================================================

---
# Resource 1: Namespace - Environment isolation
# Purpose: Isolates resources and provides environment boundaries
# Benefits: Multi-tenancy, resource quotas, network policies scope
apiVersion: v1
kind: Namespace
metadata:
  name: myapp-production
  labels:
    name: myapp-production
    environment: production
    team: backend
  annotations:
    # Enable Istio sidecar injection for service mesh
    istio-injection: enabled

---
# Resource 2: ServiceAccount - Security identity with AWS IAM integration
# Purpose: Provides pod identity and integrates with AWS IAM for secure access
# Benefits: Fine-grained permissions, AWS service access, audit trail
apiVersion: v1
kind: ServiceAccount
metadata:
  name: myapp-service-account
  namespace: myapp-production
  annotations:
    # AWS IAM role for service account (IRSA) integration
    eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/MyAppRole
    # Audience for OIDC token
    eks.amazonaws.com/audience: sts.amazonaws.com
automountServiceAccountToken: true

---
# Resource 3: Role - Minimal RBAC permissions
# Purpose: Defines minimal required permissions following principle of least privilege
# Benefits: Security hardening, compliance, reduced attack surface
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: myapp-role
  namespace: myapp-production
rules:
  # Allow reading ConfigMaps and Secrets for application configuration
  - apiGroups: [""]
    resources: ["configmaps", "secrets"]
    verbs: ["get", "list"]
  # Allow reading own pod information
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]
    resourceNames: ["myapp-*"]
  # Allow creating events for logging
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create"]

---
# Resource 4: RoleBinding - Permission assignments
# Purpose: Binds the Role to ServiceAccount, granting specific permissions
# Benefits: Secure access control, audit compliance, permission management
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: myapp-role-binding
  namespace: myapp-production
subjects:
  - kind: ServiceAccount
    name: myapp-service-account
    namespace: myapp-production
roleRef:
  kind: Role
  name: myapp-role
  apiGroup: rbac.authorization.k8s.io

---
# Resource 5: PriorityClass - High-priority scheduling
# Purpose: Ensures critical application pods get priority during resource contention
# Benefits: Improved availability, better resource allocation, SLA compliance
apiVersion: scheduling.k8s.io/v1
kind: PriorityClass
metadata:
  name: myapp-high-priority
# Higher values = higher priority (system pods typically use 2000000000)
value: 1000000
globalDefault: false
description: "High priority class for MyApp production workloads"

---
# Resource 6: PersistentVolumeClaim - 50Gi encrypted storage
# Purpose: Provides persistent, encrypted storage for application data
# Benefits: Data persistence, encryption at rest, performance optimization
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myapp-storage
  namespace: myapp-production
  labels:
    app: myapp
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: gp3-encrypted  # AWS EBS GP3 with encryption
  resources:
    requests:
      storage: 50Gi
  # Selector for specific storage requirements
  selector:
    matchLabels:
      environment: production

---
# Resource 7: ConfigMap - Comprehensive Spring Boot + Nginx configuration
# Purpose: Stores non-sensitive configuration data for application and proxy
# Benefits: Configuration externalization, easy updates, environment-specific configs
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config
  namespace: myapp-production
  labels:
    app: myapp
    component: config
data:
  # Spring Boot application properties
  application.yml: |
    server:
      port: 8080
      servlet:
        context-path: /api/v1
    spring:
      profiles:
        active: production
      datasource:
        hikari:
          maximum-pool-size: 20
          minimum-idle: 5
          connection-timeout: 30000
      jpa:
        hibernate:
          ddl-auto: validate
        show-sql: false
      redis:
        timeout: 2000ms
        jedis:
          pool:
            max-active: 20
            max-idle: 10
    logging:
      level:
        com.myapp: INFO
        org.springframework.security: WARN
    management:
      endpoints:
        web:
          exposure:
            include: health,metrics,prometheus
      endpoint:
        health:
          show-details: when-authorized
  
  # Nginx reverse proxy configuration
  nginx.conf: |
    events {
        worker_connections 1024;
    }
    http {
        upstream backend {
            server localhost:8080;
            keepalive 32;
        }
        server {
            listen 80;
            location /health {
                access_log off;
                proxy_pass http://backend/actuator/health;
            }
            location / {
                proxy_pass http://backend;
                proxy_http_version 1.1;
                proxy_set_header Connection "";
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }
        }
    }

---
# Resource 8: Secret - Database, Redis, JWT, API keys, OAuth2 credentials
# Purpose: Securely stores sensitive configuration data with encryption
# Benefits: Security, compliance, centralized secret management
apiVersion: v1
kind: Secret
metadata:
  name: myapp-secrets
  namespace: myapp-production
  labels:
    app: myapp
    component: secrets
type: Opaque
data:
  # Database credentials (base64 encoded)
  database-url: cG9zdGdyZXNxbDovL3VzZXI6cGFzc0BkYi5leGFtcGxlLmNvbTo1NDMyL215YXBw
  database-username: bXlhcHB1c2Vy
  database-password: c3VwZXJTZWN1cmVQYXNzd29yZDEyMyE=
  
  # Redis credentials
  redis-url: cmVkaXM6Ly91c2VyOnBhc3NAcmVkaXMuZXhhbXBsZS5jb206NjM3OS8w
  redis-password: cmVkaXNTZWN1cmVQYXNzd29yZA==
  
  # JWT configuration
  jwt-secret: bXlTdXBlclNlY3VyZUpXVFNlY3JldEtleTEyMzQ1Njc4OTA=
  jwt-issuer: bXlhcHAtcHJvZHVjdGlvbg==
  
  # External API keys
  api-key-external-service: YWJjZGVmZ2hpams=
  api-secret-external-service: bGxtbm9wcXJzdHV2d3h5eg==
  
  # OAuth2 credentials
  oauth2-client-id: bXlhcHAtY2xpZW50LWlk
  oauth2-client-secret: bXlhcHAtY2xpZW50LXNlY3JldC12ZXJ5LXNlY3VyZQ==

---
# Resource 9: Deployment - Production-grade with 8 replicas, init containers, health checks
# Purpose: Manages application lifecycle with high availability and reliability
# Benefits: Rolling updates, self-healing, scalability, health monitoring
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myapp-deployment
  namespace: myapp-production
  labels:
    app: myapp
    version: v1.0.0
    component: backend
spec:
  replicas: 8  # High availability with 8 replicas
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 2        # Allow 2 extra pods during update
      maxUnavailable: 1  # Keep at least 7 pods running
  selector:
    matchLabels:
      app: myapp
      component: backend
  template:
    metadata:
      labels:
        app: myapp
        component: backend
        version: v1.0.0
      annotations:
        # Prometheus scraping configuration
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/actuator/prometheus"
    spec:
      serviceAccountName: myapp-service-account
      priorityClassName: myapp-high-priority
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        fsGroup: 2000
      
      # Init container for database migration and health checks
      initContainers:
        - name: db-migration
          image: myapp/migrations:latest
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: myapp-secrets
                  key: database-url
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "200m"
        
        - name: dependency-check
          image: busybox:1.35
          command: ['sh', '-c']
          args:
            - |
              echo "Checking database connectivity..."
              until nc -z postgres-service 5432; do
                echo "Waiting for database..."
                sleep 2
              done
              echo "Database is ready!"
              
              echo "Checking Redis connectivity..."
              until nc -z redis-service 6379; do
                echo "Waiting for Redis..."
                sleep 2
              done
              echo "Redis is ready!"
      
      containers:
        # Main application container
        - name: myapp
          image: myapp/backend:v1.0.0
          ports:
            - containerPort: 8080
              name: http
              protocol: TCP
          env:
            - name: SPRING_PROFILES_ACTIVE
              value: "production"
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: myapp-secrets
                  key: database-url
            - name: REDIS_URL
              valueFrom:
                secretKeyRef:
                  name: myapp-secrets
                  key: redis-url
            - name: JWT_SECRET
              valueFrom:
                secretKeyRef:
                  name: myapp-secrets
                  key: jwt-secret
          
          # Volume mounts for configuration and persistent storage
          volumeMounts:
            - name: config-volume
              mountPath: /app/config
              readOnly: true
            - name: storage-volume
              mountPath: /app/data
          
          # Resource requirements for optimal performance
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "1Gi"
              cpu: "500m"
          
          # Health check configuration
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 60
            periodSeconds: 30
            timeoutSeconds: 10
            failureThreshold: 3
          
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          
          # Startup probe for slow-starting applications
          startupProbe:
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 30
        
        # Nginx sidecar container for reverse proxy
        - name: nginx-proxy
          image: nginx:1.25-alpine
          ports:
            - containerPort: 80
              name: proxy
          volumeMounts:
            - name: nginx-config
              mountPath: /etc/nginx/nginx.conf
              subPath: nginx.conf
              readOnly: true
          resources:
            requests:
              memory: "64Mi"
              cpu: "50m"
            limits:
              memory: "128Mi"
              cpu: "100m"
      
      # Volume definitions
      volumes:
        - name: config-volume
          configMap:
            name: myapp-config
        - name: nginx-config
          configMap:
            name: myapp-config
            items:
              - key: nginx.conf
                path: nginx.conf
        - name: storage-volume
          persistentVolumeClaim:
            claimName: myapp-storage

# =============================================================================
# NETWORKING & ACCESS (Resources 10-14)
# =============================================================================

---
# Resource 10: Service - ClusterIP with AWS NLB annotations
# Purpose: Exposes application internally and configures AWS Network Load Balancer
# Benefits: Service discovery, load balancing, external access
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
  namespace: myapp-production
  labels:
    app: myapp
    component: service
  annotations:
    # AWS Load Balancer Controller annotations for NLB
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-path: "/actuator/health"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval-seconds: "30"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout-seconds: "10"
    service.beta.kubernetes.io/aws-load-balancer-healthy-threshold-count: "2"
    service.beta.kubernetes.io/aws-load-balancer-unhealthy-threshold-count: "3"
spec:
  type: ClusterIP  # Internal service discovery
  selector:
    app: myapp
    component: backend
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocol: TCP
    - name: proxy
      port: 8080
      targetPort: 80
      protocol: TCP

---
# Resource 11: HorizontalPodAutoscaler - Scales 5-50 pods with custom metrics
# Purpose: Automatically scales pods based on CPU, memory, and custom metrics
# Benefits: Cost optimization, performance maintenance, automatic scaling
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: myapp-hpa
  namespace: myapp-production
  labels:
    app: myapp
    component: autoscaler
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: myapp-deployment
  minReplicas: 5   # Minimum pods for high availability
  maxReplicas: 50  # Maximum pods for cost control
  metrics:
    # CPU utilization metric
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    
    # Memory utilization metric
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    
    # Custom metric - requests per second
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "100"
    
    # Custom metric - response time
    - type: Pods
      pods:
        metric:
          name: http_request_duration_seconds
        target:
          type: AverageValue
          averageValue: "500m"  # 500ms
  
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
        - type: Percent
          value: 100
          periodSeconds: 60
        - type: Pods
          value: 4
          periodSeconds: 60
      selectPolicy: Max
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Percent
          value: 50
          periodSeconds: 60
        - type: Pods
          value: 2
          periodSeconds: 60
      selectPolicy: Min

---
# Resource 12: PodDisruptionBudget - Maintains 3 minimum pods
# Purpose: Ensures minimum number of pods remain available during disruptions
# Benefits: High availability, graceful maintenance, SLA compliance
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: myapp-pdb
  namespace: myapp-production
  labels:
    app: myapp
    component: availability
spec:
  minAvailable: 3  # Always keep at least 3 pods running
  selector:
    matchLabels:
      app: myapp
      component: backend

---
# Resource 13: NetworkPolicy - Comprehensive micro-segmentation
# Purpose: Implements network security and traffic flow control
# Benefits: Security isolation, compliance, attack surface reduction
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: myapp-network-policy
  namespace: myapp-production
  labels:
    app: myapp
    component: security
spec:
  podSelector:
    matchLabels:
      app: myapp
  policyTypes:
    - Ingress
    - Egress
  
  # Ingress rules - what can connect to our pods
  ingress:
    # Allow traffic from Istio gateway
    - from:
        - namespaceSelector:
            matchLabels:
              name: istio-system
        - podSelector:
            matchLabels:
              app: istio-gateway
      ports:
        - protocol: TCP
          port: 8080
    
    # Allow traffic from monitoring namespace
    - from:
        - namespaceSelector:
            matchLabels:
              name: monitoring
        - podSelector:
            matchLabels:
              app: prometheus
      ports:
        - protocol: TCP
          port: 8080
    
    # Allow intra-namespace communication
    - from:
        - namespaceSelector:
            matchLabels:
              name: myapp-production
      ports:
        - protocol: TCP
          port: 8080
  
  # Egress rules - what our pods can connect to
  egress:
    # Allow DNS resolution
    - to: []
      ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
    
    # Allow HTTPS for external API calls
    - to: []
      ports:
        - protocol: TCP
          port: 443
    
    # Allow database access
    - to:
        - namespaceSelector:
            matchLabels:
              name: database
      ports:
        - protocol: TCP
          port: 5432
    
    # Allow Redis access
    - to:
        - namespaceSelector:
            matchLabels:
              name: cache
      ports:
        - protocol: TCP
          port: 6379
    
    # Allow monitoring traffic
    - to:
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: 9090

---
# Resource 14: Ingress - SSL termination, rate limiting, security headers
# Purpose: Manages external access with SSL, security, and traffic controls
# Benefits: SSL termination, security headers, rate limiting, centralized routing
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: myapp-ingress
  namespace: myapp-production
  labels:
    app: myapp
    component: ingress
  annotations:
    # Ingress class and SSL configuration
    kubernetes.io/ingress.class: "nginx"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    
    # Rate limiting configuration
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    nginx.ingress.kubernetes.io/rate-limit-connections: "10"
    
    # Security headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      add_header X-Frame-Options "SAMEORIGIN" always;
      add_header X-Content-Type-Options "nosniff" always;
      add_header X-XSS-Protection "1; mode=block" always;
      add_header Referrer-Policy "strict-origin-when-cross-origin" always;
      add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'" always;
      add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    
    # Performance and caching
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-origin: "https://myapp.com"
    nginx.ingress.kubernetes.io/proxy-buffer-size: "8k"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
spec:
  tls:
    - hosts:
        - api.myapp.com
        - myapp.com
      secretName: myapp-tls-cert
  rules:
    - host: api.myapp.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: myapp-service
                port:
                  number: 80
    - host: myapp.com
      http:
        paths:
          - path: /api
            pathType: Prefix
            backend:
              service:
                name: myapp-service
                port:
                  number: 80

# =============================================================================
# MONITORING & OBSERVABILITY (Resources 15-16)
# =============================================================================

---
# Resource 15: ServiceMonitor - Prometheus scraping configuration
# Purpose: Configures Prometheus to scrape metrics from application
# Benefits: Automated monitoring, metrics collection, observability
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: myapp-service-monitor
  namespace: myapp-production
  labels:
    app: myapp
    component: monitoring
spec:
  selector:
    matchLabels:
      app: myapp
      component: service
  endpoints:
    - port: http
      path: /actuator/prometheus
      interval: 15s
      scrapeTimeout: 10s
      honorLabels: true
      # Metric relabeling for better organization
      metricRelabelings:
        - sourceLabels: [__name__]
          regex: 'jvm_.*'
          targetLabel: category
          replacement: 'jvm'
        - sourceLabels: [__name__]
          regex: 'http_.*'
          targetLabel: category
          replacement: 'http'
        - sourceLabels: [__name__]
          regex: 'spring_.*'
          targetLabel: category
          replacement: 'spring'
  namespaceSelector:
    matchNames:
      - myapp-production

---
# Resource 16: PrometheusRule - 5 critical alerting rules
# Purpose: Defines alerting rules for critical application and infrastructure issues
# Benefits: Proactive monitoring, incident response, SLA maintenance
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: myapp-alerts
  namespace: myapp-production
  labels:
    app: myapp
    component: alerting
spec:
  groups:
    - name: myapp.critical
      interval: 30s
      rules:
        # Alert 1: High error rate
        - alert: MyAppHighErrorRate
          expr: |
            (
              rate(http_server_requests_seconds_count{job="myapp-service",status=~"5.."}[5m]) /
              rate(http_server_requests_seconds_count{job="myapp-service"}[5m])
            ) * 100 > 5
          for: 2m
          labels:
            severity: critical
            service: myapp
            team: backend
          annotations:
            summary: "MyApp has high error rate"
            description: "MyApp error rate is {{ $value }}% for the last 5 minutes"
            runbook_url: "https://runbooks.myapp.com/high-error-rate"
        
        # Alert 2: High response time
        - alert: MyAppHighResponseTime
          expr: |
            histogram_quantile(0.95,
              rate(http_server_requests_seconds_bucket{job="myapp-service"}[5m])
            ) > 1
          for: 3m
          labels:
            severity: warning
            service: myapp
            team: backend
          annotations:
            summary: "MyApp has high response time"
            description: "MyApp 95th percentile response time is {{ $value }}s"
            runbook_url: "https://runbooks.myapp.com/high-response-time"
        
        # Alert 3: Low pod availability
        - alert: MyAppLowPodAvailability
          expr: |
            (
              kube_deployment_status_replicas_available{deployment="myapp-deployment"} /
              kube_deployment_spec_replicas{deployment="myapp-deployment"}
            ) * 100 < 80
          for: 1m
          labels:
            severity: critical
            service: myapp
            team: backend
          annotations:
            summary: "MyApp has low pod availability"
            description: "Only {{ $value }}% of MyApp pods are available"
            runbook_url: "https://runbooks.myapp.com/low-pod-availability"
        
        # Alert 4: High memory usage
        - alert: MyAppHighMemoryUsage
          expr: |
            (
              container_memory_working_set_bytes{container="myapp",namespace="myapp-production"} /
              container_spec_memory_limit_bytes{container="myapp",namespace="myapp-production"}
            ) * 100 > 85
          for: 5m
          labels:
            severity: warning
            service: myapp
            team: backend
          annotations:
            summary: "MyApp has high memory usage"
            description: "MyApp memory usage is {{ $value }}% of limit"
            runbook_url: "https://runbooks.myapp.com/high-memory-usage"
        
        # Alert 5: Database connection issues
        - alert: MyAppDatabaseConnectionFailed
          expr: |
            hikaricp_connections_active{job="myapp-service"} == 0
          for: 1m
          labels:
            severity: critical
            service: myapp
            team: backend
          annotations:
            summary: "MyApp cannot connect to database"
            description: "MyApp has no active database connections"
            runbook_url: "https://runbooks.myapp.com/database-connection-failed"

# =============================================================================
# SERVICE MESH (Resources 17-21) - Istio Configuration
# =============================================================================

---
# Resource 17: DestinationRule - Traffic policies, circuit breaking
# Purpose: Configures traffic policies and circuit breaker patterns
# Benefits: Resilience, load balancing, traffic management
apiVersion: networking.istio.io/v1beta1
kind: DestinationRule
metadata:
  name: myapp-destination-rule
  namespace: myapp-production
  labels:
    app: myapp
    component: service-mesh
spec:
  host: myapp-service.myapp-production.svc.cluster.local
  trafficPolicy:
    # Load balancing configuration
    loadBalancer:
      simple: LEAST_CONN
    
    # Connection pool settings
    connectionPool:
      tcp:
        maxConnections: 100
        connectTimeout: 30s
        keepAlive:
          time: 7200s
          interval: 75s
      http:
        http1MaxPendingRequests: 50
        http2MaxRequests: 100
        maxRequestsPerConnection: 10
        maxRetries: 3
        consecutiveGatewayErrors: 5
        interval: 30s
        baseEjectionTime: 30s
        maxEjectionPercent: 50
        minHealthPercent: 50
    
    # Circuit breaker configuration
    outlierDetection:
      consecutiveGatewayErrors: 3
      consecutive5xxErrors: 3
      interval: 30s
      baseEjectionTime: 30s
      maxEjectionPercent: 50
      minHealthPercent: 50
      splitExternalLocalOriginErrors: false
  
  # Subset configuration for canary deployments
  subsets:
    - name: v1
      labels:
        version: v1.0.0
    - name: canary
      labels:
        version: canary

---
# Resource 18: VirtualService - Advanced routing, retries, fault injection
# Purpose: Configures advanced traffic routing and resilience patterns
# Benefits: Traffic splitting, fault tolerance, testing capabilities
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: myapp-virtual-service
  namespace: myapp-production
  labels:
    app: myapp
    component: service-mesh
spec:
  hosts:
    - myapp-service.myapp-production.svc.cluster.local
    - api.myapp.com
  gateways:
    - myapp-gateway
    - mesh  # For internal traffic
  http:
    # Route for health checks (no retries)
    - match:
        - uri:
            prefix: /actuator/health
      route:
        - destination:
            host: myapp-service.myapp-production.svc.cluster.local
            port:
              number: 80
      timeout: 5s
    
    # Canary routing - 10% traffic to canary version
    - match:
        - headers:
            canary:
              exact: "true"
      route:
        - destination:
            host: myapp-service.myapp-production.svc.cluster.local
            port:
              number: 80
            subset: canary
      retries:
        attempts: 3
        perTryTimeout: 10s
        retryOn: gateway-error,connect-failure,refused-stream
      fault:
        delay:
          percentage:
            value: 0.1
          fixedDelay: 5s
    
    # Main traffic routing with weighted distribution
    - match:
        - uri:
            prefix: /api/v1
      route:
        - destination:
            host: myapp-service.myapp-production.svc.cluster.local
            port:
              number: 80
            subset: v1
          weight: 90
        - destination:
            host: myapp-service.myapp-production.svc.cluster.local
            port:
              number: 80
            subset: canary
          weight: 10
      retries:
        attempts: 3
        perTryTimeout: 10s
        retryOn: gateway-error,connect-failure,refused-stream
      timeout: 30s
      
      # Fault injection for testing (disabled in production)
      fault:
        abort:
          percentage:
            value: 0.01  # 0.01% of requests
          httpStatus: 500
    
    # Default route
    - route:
        - destination:
            host: myapp-service.myapp-production.svc.cluster.local
            port:
              number: 80
            subset: v1
      retries:
        attempts: 2
        perTryTimeout: 15s
        retryOn: gateway-error,connect-failure,refused-stream
      timeout: 30s

---
# Resource 19: Gateway - Istio ingress with TLS 1.3
# Purpose: Configures Istio ingress gateway with modern TLS configuration
# Benefits: Secure ingress, TLS termination, centralized traffic entry
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: myapp-gateway
  namespace: myapp-production
  labels:
    app: myapp
    component: service-mesh
spec:
  selector:
    istio: ingressgateway
  servers:
    # HTTPS server with TLS 1.3
    - port:
        number: 443
        name: https
        protocol: HTTPS
      tls:
        mode: SIMPLE
        credentialName: myapp-tls-cert
        minProtocolVersion: TLSV1_3
        maxProtocolVersion: TLSV1_3
        cipherSuites:
          - ECDHE-RSA-AES128-GCM-SHA256
          - ECDHE-RSA-AES256-GCM-SHA384
          - ECDHE-RSA-CHACHA20-POLY1305
      hosts:
        - api.myapp.com
        - myapp.com
    
    # HTTP server (redirects to HTTPS)
    - port:
        number: 80
        name: http
        protocol: HTTP
      hosts:
        - api.myapp.com
        - myapp.com
      tls:
        httpsRedirect: true

---
# Resource 20: AuthorizationPolicy - JWT-based access control
# Purpose: Implements JWT-based authentication and authorization
# Benefits: Secure API access, token validation, fine-grained permissions
apiVersion: security.istio.io/v1beta1
kind: AuthorizationPolicy
metadata:
  name: myapp-authz-policy
  namespace: myapp-production
  labels:
    app: myapp
    component: security
spec:
  selector:
    matchLabels:
      app: myapp
      component: backend
  
  # Allow health check endpoints without authentication
  rules:
    - to:
        - operation:
            paths: ["/actuator/health", "/actuator/health/*"]
    
    # Allow public API endpoints
    - to:
        - operation:
            paths: ["/api/v1/public/*"]
    
    # Require JWT for protected endpoints
    - from:
        - source:
            requestPrincipals: ["myapp-production/myapp-user"]
      to:
        - operation:
            paths: ["/api/v1/users/*"]
      when:
        - key: request.auth.claims[role]
          values: ["user", "admin"]
    
    # Admin-only endpoints
    - from:
        - source:
            requestPrincipals: ["myapp-production/myapp-admin"]
      to:
        - operation:
            paths: ["/api/v1/admin/*"]
      when:
        - key: request.auth.claims[role]
          values: ["admin"]
    
    # Rate limiting based on JWT claims
    - from:
        - source:
            requestPrincipals: ["myapp-production/myapp-user"]
      to:
        - operation:
            paths: ["/api/v1/*"]
      when:
        - key: request.auth.claims[tier]
          values: ["premium"]
          # Premium users get higher rate limits

---
# Resource 21: PeerAuthentication - Strict mTLS enforcement
# Purpose: Enforces mutual TLS for all service-to-service communication
# Benefits: Encryption in transit, service identity verification, zero-trust security
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: myapp-peer-auth
  namespace: myapp-production
  labels:
    app: myapp
    component: security
spec:
  selector:
    matchLabels:
      app: myapp
  mtls:
    mode: STRICT  # Enforce mTLS for all traffic
  
  # Port-specific mTLS configuration
  portLevelMtls:
    8080:
      mode: STRICT

---
# Resource 22: RequestAuthentication - JWT validation configuration
# Purpose: Configures JWT token validation for API requests
# Benefits: Token validation, issuer verification, claims extraction
apiVersion: security.istio.io/v1beta1
kind: RequestAuthentication
metadata:
  name: myapp-request-auth
  namespace: myapp-production
  labels:
    app: myapp
    component: security
spec:
  selector:
    matchLabels:
      app: myapp
      component: backend
  jwtRules:
    - issuer: "https://auth.myapp.com"
      jwksUri: "https://auth.myapp.com/.well-known/jwks.json"
      audiences:
        - "myapp-api"
        - "myapp-web"
      # JWT validation configuration
      forwardOriginalToken: true
      fromHeaders:
        - name: Authorization
          prefix: "Bearer "
      fromParams:
        - "access_token"
      outputPayloadToHeader: "x-jwt-payload"

# =============================================================================
# OPERATIONS & MAINTENANCE (Resources 23-25)
# =============================================================================

---
# Resource 23: ConfigMap - Grafana Dashboard configuration
# Purpose: Pre-configured monitoring dashboard for application metrics
# Benefits: Observability, performance monitoring, troubleshooting
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-grafana-dashboard
  namespace: myapp-production
  labels:
    app: myapp
    component: monitoring
    grafana_dashboard: "1"
data:
  myapp-dashboard.json: |
    {
      "dashboard": {
        "id": null,
        "title": "MyApp Production Dashboard",
        "tags": ["myapp", "production"],
        "timezone": "UTC",
        "refresh": "30s",
        "time": {
          "from": "now-1h",
          "to": "now"
        },
        "panels": [
          {
            "id": 1,
            "title": "Request Rate",
            "type": "graph",
            "targets": [
              {
                "expr": "rate(http_server_requests_seconds_count{job=\"myapp-service\"}[5m])",
                "legendFormat": "{{method}} {{status}}"
              }
            ],
            "yAxes": [
              {
                "label": "Requests/sec",
                "min": 0
              }
            ]
          },
          {
            "id": 2,
            "title": "Response Time",
            "type": "graph",
            "targets": [
              {
                "expr": "histogram_quantile(0.95, rate(http_server_requests_seconds_bucket{job=\"myapp-service\"}[5m]))",
                "legendFormat": "95th percentile"
              },
              {
                "expr": "histogram_quantile(0.50, rate(http_server_requests_seconds_bucket{job=\"myapp-service\"}[5m]))",
                "legendFormat": "50th percentile"
              }
            ],
            "yAxes": [
              {
                "label": "Seconds",
                "min": 0
              }
            ]
          },
          {
            "id": 3,
            "title": "Error Rate",
            "type": "singlestat",
            "targets": [
              {
                "expr": "rate(http_server_requests_seconds_count{job=\"myapp-service\",status=~\"5..\"}[5m]) / rate(http_server_requests_seconds_count{job=\"myapp-service\"}[5m]) * 100",
                "legendFormat": "Error Rate %"
              }
            ],
            "thresholds": "2,5",
            "colorBackground": true
          },
          {
            "id": 4,
            "title": "Pod Status",
            "type": "table",
            "targets": [
              {
                "expr": "kube_pod_status_phase{namespace=\"myapp-production\",pod=~\"myapp-.*\"}",
                "format": "table"
              }
            ]
          },
          {
            "id": 5,
            "title": "JVM Memory Usage",
            "type": "graph",
            "targets": [
              {
                "expr": "jvm_memory_used_bytes{job=\"myapp-service\",area=\"heap\"}",
                "legendFormat": "Heap Used"
              },
              {
                "expr": "jvm_memory_max_bytes{job=\"myapp-service\",area=\"heap\"}",
                "legendFormat": "Heap Max"
              }
            ],
            "yAxes": [
              {
                "label": "Bytes",
                "min": 0
              }
            ]
          }
        ]
      }
    }

---
# Resource 24: Job - Database migration scripts
# Purpose: Manages database schema migrations and updates
# Benefits: Version control for DB, automated migrations, rollback capability
apiVersion: batch/v1
kind: Job
metadata:
  name: myapp-db-migration
  namespace: myapp-production
  labels:
    app: myapp
    component: migration
    version: v1.0.0
spec:
  template:
    metadata:
      labels:
        app: myapp
        component: migration
    spec:
      serviceAccountName: myapp-service-account
      restartPolicy: OnFailure
      
      # Init container to check database connectivity
      initContainers:
        - name: db-ready-check
          image: postgres:15-alpine
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: myapp-secrets
                  key: database-url
          command:
            - sh
            - -c
            - |
              echo "Checking database connectivity..."
              until pg_isready -h $DB_HOST -p $DB_PORT -U $DB_USER; do
                echo "Waiting for database..."
                sleep 2
              done
              echo "Database is ready!"
      
      containers:
        - name: migration
          image: myapp/db-migrations:v1.0.0
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: myapp-secrets
                  key: database-url
            - name: MIGRATION_MODE
              value: "upgrade"
            - name: MIGRATION_VERSION
              value: "v1.0.0"
          resources:
            requests:
              memory: "256Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "200m"
          # Migration scripts volume
          volumeMounts:
            - name: migration-scripts
              mountPath: /migrations
              readOnly: true
      
      volumes:
        - name: migration-scripts
          configMap:
            name: myapp-migration-scripts
            defaultMode: 0755
  
  # Job completion and cleanup configuration
  backoffLimit: 3
  activeDeadlineSeconds: 1800  # 30 minutes timeout
  ttlSecondsAfterFinished: 86400  # Clean up after 24 hours

---
# Resource 25: CronJob - Daily automated backups
# Purpose: Automated daily backups of application data and database
# Benefits: Data protection, disaster recovery, compliance
apiVersion: batch/v1
kind: CronJob
metadata:
  name: myapp-backup-cronjob
  namespace: myapp-production
  labels:
    app: myapp
    component: backup
spec:
  # Run daily at 2 AM UTC
  schedule: "0 2 * * *"
  timeZone: "UTC"
  concurrencyPolicy: Forbid  # Don't run concurrent backup jobs
  failedJobsHistoryLimit: 3
  successfulJobsHistoryLimit: 5
  startingDeadlineSeconds: 300
  
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: myapp
            component: backup
        spec:
          serviceAccountName: myapp-service-account
          restartPolicy: OnFailure
          
          containers:
            # Database backup container
            - name: db-backup
              image: postgres:15-alpine
              env:
                - name: DATABASE_URL
                  valueFrom:
                    secretKeyRef:
                      name: myapp-secrets
                      key: database-url
                - name: BACKUP_DATE
                  value: "$(date +%Y%m%d_%H%M%S)"
                - name: AWS_ACCESS_KEY_ID
                  valueFrom:
                    secretKeyRef:
                      name: myapp-secrets
                      key: aws-access-key-id
                - name: AWS_SECRET_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: myapp-secrets
                      key: aws-secret-access-key
              command:
                - sh
                - -c
                - |
                  echo "Starting database backup..."
                  BACKUP_FILE="/backup/myapp_db_backup_$(date +%Y%m%d_%H%M%S).sql"
                  
                  # Create database dump
                  pg_dump $DATABASE_URL > $BACKUP_FILE
                  
                  # Compress backup
                  gzip $BACKUP_FILE
                  
                  # Upload to S3 (requires AWS CLI)
                  aws s3 cp ${BACKUP_FILE}.gz s3://myapp-backups/database/
                  
                  # Clean up local file
                  rm ${BACKUP_FILE}.gz
                  
                  echo "Database backup completed successfully"
              resources:
                requests:
                  memory: "512Mi"
                  cpu: "200m"
                limits:
                  memory: "1Gi"
                  cpu: "500m"
              volumeMounts:
                - name: backup-storage
                  mountPath: /backup
            
            # Application data backup container
            - name: app-data-backup
              image: alpine:3.18
              env:
                - name: AWS_ACCESS_KEY_ID
                  valueFrom:
                    secretKeyRef:
                      name: myapp-secrets
                      key: aws-access-key-id
                - name: AWS_SECRET_ACCESS_KEY
                  valueFrom:
                    secretKeyRef:
                      name: myapp-secrets
                      key: aws-secret-access-key
              command:
                - sh
                - -c
                - |
                  echo "Starting application data backup..."
                  
                  # Install AWS CLI
                  apk add --no-cache aws-cli
                  
                  # Create tar archive of application data
                  BACKUP_FILE="/backup/myapp_data_backup_$(date +%Y%m%d_%H%M%S).tar.gz"
                  tar -czf $BACKUP_FILE -C /app/data .
                  
                  # Upload to S3
                  aws s3 cp $BACKUP_FILE s3://myapp-backups/app-data/
                  
                  # Clean up local file
                  rm $BACKUP_FILE
                  
                  echo "Application data backup completed successfully"
              resources:
                requests:
                  memory: "256Mi"
                  cpu: "100m"
                limits:
                  memory: "512Mi"
                  cpu: "200m"
              volumeMounts:
                - name: backup-storage
                  mountPath: /backup
                - name: app-storage
                  mountPath: /app/data
                  readOnly: true
          
          volumes:
            - name: backup-storage
              persistentVolumeClaim:
                claimName: myapp-backup-pvc
            - name: app-storage
              persistentVolumeClaim:
                claimName: myapp-storage
      
      # Job completion configuration
      backoffLimit: 2
      activeDeadlineSeconds: 7200  # 2 hours timeout
      ttlSecondsAfterFinished: 604800  # Clean up after 7 days

---
# Resource 26: PersistentVolumeClaim - Dedicated backup storage
# Purpose: Provides dedicated storage for backup operations
# Benefits: Backup isolation, performance optimization, storage management
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myapp-backup-pvc
  namespace: myapp-production
  labels:
    app: myapp
    component: backup
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: gp3-encrypted
  resources:
    requests:
      storage: 100Gi  # Larger storage for backup retention
  selector:
    matchLabels:
      backup: "true"
      environment: production

# =============================================================================
# ADDITIONAL CONFIGURATION RESOURCES
# =============================================================================

---
# ConfigMap for migration scripts
apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-migration-scripts
  namespace: myapp-production
  labels:
    app: myapp
    component: migration
data:
  # Migration script example
  001_initial_schema.sql: |
    -- Initial schema migration
    CREATE TABLE IF NOT EXISTS users (
        id BIGSERIAL PRIMARY KEY,
        username VARCHAR(255) UNIQUE NOT NULL,
        email VARCHAR(255) UNIQUE NOT NULL,
        password_hash VARCHAR(255) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE INDEX idx_users_username ON users(username);
    CREATE INDEX idx_users_email ON users(email);
  
  002_add_user_profiles.sql: |
    -- Add user profiles table
    CREATE TABLE IF NOT EXISTS user_profiles (
        id BIGSERIAL PRIMARY KEY,
        user_id BIGINT REFERENCES users(id) ON DELETE CASCADE,
        first_name VARCHAR(255),
        last_name VARCHAR(255),
        bio TEXT,
        avatar_url VARCHAR(500),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    
    CREATE INDEX idx_user_profiles_user_id ON user_profiles(user_id);
  
  migrate.sh: |
    #!/bin/bash
    set -e
    
    echo "Starting database migration..."
    
    # Run migrations in order
    for migration in /migrations/*.sql; do
        if [ -f "$migration" ]; then
            echo "Running migration: $(basename $migration)"
            psql $DATABASE_URL -f "$migration"
        fi
    done
    
    echo "Database migration completed successfully!"

# =============================================================================
# TEMPLATE USAGE INSTRUCTIONS
# =============================================================================

# To deploy this complete stack:
# 1. Update all placeholder values (image names, domains, secrets, etc.)
# 2. Ensure prerequisites are installed (Istio, Prometheus Operator, cert-manager)
# 3. Create secrets with actual values (base64 encoded)
# 4. Apply resources in order:
#    kubectl apply -f this-template.yaml
# 5. Verify deployment:
#    kubectl get all -n myapp-production
# 6. Check monitoring:
#    kubectl port-forward -n monitoring svc/grafana 3000:3000
# 7. Test ingress:
#    curl -k https://api.myapp.com/actuator/health

# =============================================================================
# CUSTOMIZATION CHECKLIST
# =============================================================================

# □ Update namespace name and labels
# □ Replace image names with your actual images  
# □ Update domain names in Ingress and Gateway
# □ Generate and encode actual secrets
# □ Adjust resource requests/limits based on your needs
# □ Configure storage classes for your cluster
# □ Update AWS annotations for your account
# □ Customize monitoring queries and alerts
# □ Configure backup S3 bucket names
# □ Update migration scripts for your schema
# □ Adjust scaling parameters (min/max replicas)
# □ Configure network policies for your architecture
# □ Update JWT issuer and JWKS URLs
# □ Customize Grafana dashboard panels
# □ Set appropriate backup retention policies