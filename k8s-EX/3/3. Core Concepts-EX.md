# Kubernetes Complete Mastery Guide - From Basics to intermediate 

## Introduction: Building Real-World Kubernetes Expertise

This comprehensive guide takes you from absolute beginner to production-ready Kubernetes expert through hands-on examples, practical demos, and real-world mini-projects. Each section builds upon the previous one, ensuring you develop both theoretical understanding and practical skills.

**What Makes This Guide Different:**
- **Progressive Learning**: Each concept builds naturally on the previous one
- **Real-World Focus**: Examples mirror actual production scenarios
- **Hands-On Practice**: Every concept includes practical exercises
- **Production Readiness**: Advanced sections cover enterprise patterns
- **Complete Mini-Projects**: End-to-end applications you can deploy

**Learning Path Overview:**
1. **Foundation** (Pods, ReplicaSets, Deployments)
2. **Basic Examples** (Single-service applications)
3. **Intermediate Demos** (Multi-service applications)
4. **Advanced Projects** (Production-ready systems)
5. **Expert-Level** (Custom controllers, operators)

---

## Part I: Foundation Concepts with Hands-On Examples

### Chapter 1: Understanding Pods Through Progressive Examples

#### Example 1.1: Your First Pod - Web Server
Let's start with the simplest possible example and gradually add complexity.

**Basic Pod Creation:**
```bash
# Example 1.1a: Minimal pod
kubectl run my-first-pod --image=nginx:1.21 --port=80 --restart=Never

# Watch it start up
kubectl get pods -w

# Access it locally
kubectl port-forward pod/my-first-pod 8080:80

# Test it works
curl http://localhost:8080
```

**Understanding What Happened:**
```bash
# Examine the pod details
kubectl describe pod my-first-pod

# See the generated YAML
kubectl get pod my-first-pod -o yaml > my-first-pod.yaml
cat my-first-pod.yaml
```

#### Example 1.2: Enhanced Pod with Configuration

Now let's add environment variables and resource limits:

```yaml
# enhanced-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: enhanced-web-pod
  labels:
    app: web-server
    version: v1
    environment: learning
spec:
  containers:
  - name: nginx
    image: nginx:1.21
    ports:
    - containerPort: 80
      name: http
    env:
    - name: NGINX_PORT
      value: "80"
    - name: ENVIRONMENT
      value: "learning"
    resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "128Mi"
        cpu: "200m"
    volumeMounts:
    - name: html-content
      mountPath: /usr/share/nginx/html
  volumes:
  - name: html-content
    configMap:
      name: web-content
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: web-content
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head><title>My Enhanced Pod</title></head>
    <body>
        <h1>Hello from Enhanced Pod!</h1>
        <p>Environment: learning</p>
        <p>Pod Name: enhanced-web-pod</p>
        <p>This content comes from a ConfigMap!</p>
    </body>
    </html>
```

**Deploy and Test:**
```bash
# Apply the configuration
kubectl apply -f enhanced-pod.yaml

# Verify both resources were created
kubectl get pods,configmaps

# Test the custom content
kubectl port-forward pod/enhanced-web-pod 8080:80
curl http://localhost:8080
```

#### Example 1.3: Multi-Container Pod - Sidecar Pattern

This example demonstrates how containers in a pod work together:

```yaml
# sidecar-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-with-sidecar
  labels:
    app: web-with-logging
spec:
  containers:
  # Main application container
  - name: web-server
    image: nginx:1.21
    ports:
    - containerPort: 80
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
    - name: web-content
      mountPath: /usr/share/nginx/html
      
  # Sidecar logging container
  - name: log-processor
    image: busybox:1.35
    command:
    - /bin/sh
    - -c
    - |
      echo "Log processor starting..."
      while true; do
        echo "$(date): Processing logs..." >> /shared/processing.log
        if [ -f /var/log/nginx/access.log ]; then
          tail -n 5 /var/log/nginx/access.log >> /shared/recent_access.log
        fi
        sleep 30
      done
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
    - name: shared-data
      mountPath: /shared
      
  # Monitoring sidecar
  - name: metrics-collector
    image: busybox:1.35
    command:
    - /bin/sh
    - -c
    - |
      while true; do
        echo "$(date): Collecting metrics..." >> /shared/metrics.log
        echo "Active connections: $(netstat -an | grep :80 | wc -l)" >> /shared/metrics.log
        sleep 60
      done
    volumeMounts:
    - name: shared-data
      mountPath: /shared
      
  volumes:
  - name: shared-logs
    emptyDir: {}
  - name: shared-data
    emptyDir: {}
  - name: web-content
    configMap:
      name: sidecar-content
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: sidecar-content
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head><title>Multi-Container Pod Demo</title></head>
    <body>
        <h1>Web Server with Sidecars</h1>
        <p>This pod contains:</p>
        <ul>
            <li>Main web server (nginx)</li>
            <li>Log processing sidecar</li>
            <li>Metrics collection sidecar</li>
        </ul>
        <p>All containers share the same network and storage!</p>
    </body>
    </html>
```

**Deploy and Explore:**
```bash
# Deploy the multi-container pod
kubectl apply --filename sidecar-pod.yaml

# Verify all containers are running
kubectl get pod web-with-sidecar --output jsonpath='{.spec.containers[*].name}{"\n"}'

# Check logs from each container
kubectl logs web-with-sidecar --container web-server
kubectl logs web-with-sidecar --container log-processor
kubectl logs web-with-sidecar --container metrics-collector

# Access the web server
kubectl port-forward pod/web-with-sidecar 8080:80

# Generate some traffic
for i in {1..10}; do curl http://localhost:8080; done

# Check shared files between containers
kubectl exec web-with-sidecar --container log-processor -- ls -la /shared/
kubectl exec web-with-sidecar --container metrics-collector -- cat /shared/metrics.log
```

### Chapter 2: ReplicaSets - Ensuring High Availability

#### Example 2.1: Basic ReplicaSet

```yaml
# basic-replicaset.yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-replicaset
  labels:
    app: nginx
    tier: web
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
      tier: web
  template:
    metadata:
      labels:
        app: nginx
        tier: web
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
```

**Deploy and Test Resilience:**
```bash
# Create the ReplicaSet
kubectl apply -f basic-replicaset.yaml

# Watch the pods being created
kubectl get pods --label-columns app=nginx --watch

# Test self-healing by deleting a pod
POD_TO_DELETE=$(kubectl get pods --label-columns app=nginx --output jsonpath='{.items[0].metadata.name}')
kubectl delete pod $POD_TO_DELETE

# Observe immediate replacement
kubectl get pods --label-columns app=nginx

# Scale the ReplicaSet
kubectl scale replicaset nginx-replicaset --replicas=5

# Watch scaling in action
kubectl get pods -l app=nginx -w
```

#### Example 2.2: Advanced ReplicaSet with Health Checks

```yaml
# advanced-replicaset.yaml
apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: robust-web-rs
  labels:
    app: robust-web
    version: v1
spec:
  replicas: 4
  selector:
    matchLabels:
      app: robust-web
      version: v1
  template:
    metadata:
      labels:
        app: robust-web
        version: v1
    spec:
      containers:
      - name: nginx
        image: nginx:1.21
        ports:
        - containerPort: 80
          name: http
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        # Health checks ensure only healthy pods receive traffic
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
          failureThreshold: 2
        # Security context
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          runAsNonRoot: true
          runAsUser: 101
        # Graceful shutdown
        lifecycle:
          preStop:
            exec:
              command: ["/bin/sh", "-c", "nginx -s quit; sleep 15"]
        volumeMounts:
        - name: nginx-cache
          mountPath: /var/cache/nginx
        - name: nginx-run
          mountPath: /var/run
      volumes:
      - name: nginx-cache
        emptyDir: {}
      - name: nginx-run
        emptyDir: {}
      # Spread pods across nodes for better availability
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - robust-web
              topologyKey: kubernetes.io/hostname
```

**Deploy and Monitor:**
```bash
# Deploy the advanced ReplicaSet
kubectl apply --filename advanced-replicaset.yaml

# Monitor deployment progress
kubectl get pods --label-columns app=robust-web --watch

# Check pod distribution across nodes
kubectl get pods --label-columns app=robust-web --output wide

# Test health checks by accessing a pod
kubectl port-forward $(kubectl get pods --label-columns app=robust-web --output jsonpath='{.items[0].metadata.name}') 8080:80
curl http://localhost:8080

# Simulate a failing pod (this will cause restarts)
kubectl exec $(kubectl get pods --label-columns app=robust-web --output jsonpath='{.items[0].metadata.name}') -- nginx -s stop
kubectl get pods -l app=robust-web
```

### Chapter 3: Deployments - Production-Ready Updates

#### Example 3.1: Basic Deployment with Rolling Updates

```yaml
# basic-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-deployment
  labels:
    app: web-app
    version: v1
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
        version: v1
    spec:
      containers:
      - name: web
        image: nginx:1.20
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
```

**Deployment Operations:**
```bash
# Create the deployment
kubectl apply -f basic-deployment.yaml

# Monitor the initial rollout
kubectl rollout status deployment/web-deployment

# View deployment details
kubectl describe deployment web-deployment

# Trigger an update
kubectl set image deployment/web-deployment web=nginx:1.21

# Watch the rolling update
kubectl get pods --label-columns app=web-app --watch

# Check rollout history
kubectl rollout history deployment/web-deployment

# Rollback if needed
kubectl rollout undo deployment/web-deployment
```

#### Example 3.2: Advanced Deployment with Blue-Green Strategy

```yaml
# blue-green-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: blue-green-app
  labels:
    app: blue-green-demo
spec:
  replicas: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0    # No pods unavailable during update
      maxSurge: 100%       # Double the pods during update (blue-green effect)
  selector:
    matchLabels:
      app: blue-green-demo
  template:
    metadata:
      labels:
        app: blue-green-demo
        version: blue
    spec:
      containers:
      - name: app
        image: nginx:1.20
        ports:
        - containerPort: 80
        env:
        - name: VERSION
          value: "blue"
        - name: COLOR
          value: "#0066cc"
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: app-content
          mountPath: /usr/share/nginx/html
      volumes:
      - name: app-content
        configMap:
          name: blue-version-content
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: blue-version-content
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head>
        <title>Blue-Green Deployment Demo</title>
        <style>
            body { background-color: #e6f3ff; color: #0066cc; font-family: Arial, sans-serif; text-align: center; padding: 50px; }
            .version { font-size: 24px; font-weight: bold; }
        </style>
    </head>
    <body>
        <h1>üîµ BLUE VERSION</h1>
        <div class="version">Version: Blue (v1.0)</div>
        <p>This is the current stable version</p>
        <p>Pod: <span id="hostname"></span></p>
        <script>
            document.getElementById('hostname').textContent = window.location.hostname;
        </script>
    </body>
    </html>
```

**Blue-Green Update Process:**
```bash
# Deploy the blue version
kubectl apply --filename blue-green-deployment.yaml

# Create a service to access the deployment
kubectl expose deployment blue-green-app --port=80 --target-port=80 --type=NodePort

# Test the blue version
kubectl port-forward service/blue-green-app 8080:80
curl http://localhost:8080

# Prepare the green version
cat > green-version-content.yaml << 'EOF'
apiVersion: v1
kind: ConfigMap
metadata:
  name: green-version-content
data:
  index.html: |
    <!DOCTYPE html>
    <html>
    <head>
        <title>Blue-Green Deployment Demo</title>
        <style>
            body { background-color: #e6ffe6; color: #006600; font-family: Arial, sans-serif; text-align: center; padding: 50px; }
            .version { font-size: 24px; font-weight: bold; }
        </style>
    </head>
    <body>
        <h1>üü¢ GREEN VERSION</h1>
        <div class="version">Version: Green (v2.0)</div>
        <p>This is the new updated version</p>
        <p>Pod: <span id="hostname"></span></p>
        <script>
            document.getElementById('hostname').textContent = window.location.hostname;
        </script>
    </body>
    </html>
EOF

kubectl apply --filename green-version-content.yaml

# Update deployment to use green version
kubectl patch deployment blue-green-app -p '{
  "spec": {
    "template": {
      "metadata": {
        "labels": {
          "version": "green"
        }
      },
      "spec": {
        "containers": [{
          "name": "app",
          "image": "nginx:1.21",
          "env": [
            {"name": "VERSION", "value": "green"},
            {"name": "COLOR", "value": "#006600"}
          ],
          "volumeMounts": [{
            "name": "app-content",
            "mountPath": "/usr/share/nginx/html"
          }]
        }],
        "volumes": [{
          "name": "app-content",
          "configMap": {
            "name": "green-version-content"
          }
        }]
      }
    }
  }
}'

# Watch the blue-green deployment
kubectl get pods -l app=blue-green-demo -w

# Test both versions during transition
while true; do
  curl -s http://localhost:8080 | grep -o "BLUE\|GREEN"
  sleep 1
done
```

---

## Part II: Basic Examples - Single Service Applications

### Example 4: WordPress Blog (Stateless Application)

This example demonstrates deploying a complete web application with a database.

#### 4.1: WordPress Deployment
```yaml
# wordpress-deployment.yaml
apiVersion: v1
kind: Secret
metadata:
  name: wordpress-secrets
type: Opaque
data:
  mysql-root-password: cGFzc3dvcmQxMjM=  # password123 (base64 encoded)
  mysql-password: d29yZHByZXNz123=        # wordpress123 (base64 encoded)
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: wordpress-config
data:
  wp-config-extra.php: |
    <?php
    // Extra WordPress configurations
    define('WP_DEBUG', false);
    define('WP_DEBUG_LOG', false);
    define('WP_DEBUG_DISPLAY', false);
    define('AUTOMATIC_UPDATER_DISABLED', true);
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deployment
  labels:
    app: mysql
    tier: database
spec:
  replicas: 1
  strategy:
    type: Recreate  # Database needs Recreate strategy
  selector:
    matchLabels:
      app: mysql
      tier: database
  template:
    metadata:
      labels:
        app: mysql
        tier: database
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: wordpress-secrets
              key: mysql-root-password
        - name: MYSQL_DATABASE
          value: wordpress
        - name: MYSQL_USER
          value: wordpress
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: wordpress-secrets
              key: mysql-password
        ports:
        - containerPort: 3306
          name: mysql
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        volumeMounts:
        - name: mysql-storage
          mountPath: /var/lib/mysql
        livenessProbe:
          exec:
            command:
            - mysqladmin
            - ping
            - -h
            - localhost
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - mysql
            - -h
            - localhost
            - -u
            - root
            - -ppassword123
            - -e
            - "SELECT 1"
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: mysql-storage
        emptyDir: {}
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: wordpress-deployment
  labels:
    app: wordpress
    tier: frontend
spec:
  replicas: 2
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 0
  selector:
    matchLabels:
      app: wordpress
      tier: frontend
  template:
    metadata:
      labels:
        app: wordpress
        tier: frontend
    spec:
      containers:
      - name: wordpress
        image: wordpress:6.1-apache
        env:
        - name: WORDPRESS_DB_HOST
          value: mysql-service:3306
        - name: WORDPRESS_DB_NAME
          value: wordpress
        - name: WORDPRESS_DB_USER
          value: wordpress
        - name: WORDPRESS_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: wordpress-secrets
              key: mysql-password
        ports:
        - containerPort: 80
          name: wordpress
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        volumeMounts:
        - name: wordpress-storage
          mountPath: /var/www/html
        - name: wordpress-config
          mountPath: /var/www/html/wp-config-extra.php
          subPath: wp-config-extra.php
        livenessProbe:
          httpGet:
            path: /wp-admin/install.php
            port: 80
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /wp-admin/install.php
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: wordpress-storage
        emptyDir: {}
      - name: wordpress-config
        configMap:
          name: wordpress-config
---
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
  labels:
    app: mysql
    tier: database
spec:
  selector:
    app: mysql
    tier: database
  ports:
  - port: 3306
    targetPort: 3306
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  name: wordpress-service
  labels:
    app: wordpress
    tier: frontend
spec:
  selector:
    app: wordpress
    tier: frontend
  ports:
  - port: 80
    targetPort: 80
  type: NodePort
```

**Deploy and Test WordPress:**
```bash
# Deploy WordPress and MySQL
kubectl apply --filename wordpress-deployment.yaml

# Monitor deployment progress
kubectl get deployments --watch 

# Check that all pods are running
kubectl get pods --label-columns app=wordpress
kubectl get pods --label-columns app=mysql

# Check services
kubectl get services

# Get the NodePort for WordPress
WORDPRESS_PORT=$(kubectl get service wordpress-service -o jsonpath='{.spec.ports[0].nodePort}')
echo "WordPress available on port: $WORDPRESS_PORT"

# Port forward for easy access
kubectl port-forward service/wordpress-service 8080:80

# Open http://localhost:8080 in your browser to complete WordPress setup
```

### Example 5: RESTful API with Redis Cache

This example shows a more complex application with caching.

```yaml
# api-with-cache.yaml
# ----------------------------
# Redis Deployment
# ----------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-deployment
  labels:
    app: redis
    tier: cache
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
      tier: cache
  template:
    metadata:
      labels:
        app: redis
        tier: cache
    spec:
      containers:
      - name: redis
        image: redis:7-alpine
        ports:
        - containerPort: 6379
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        livenessProbe:
          exec:
            command: ["redis-cli", "ping"]
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command: ["redis-cli", "ping"]
          initialDelaySeconds: 5
          periodSeconds: 5

---
# ----------------------------
# API Deployment
# ----------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-deployment
  labels:
    app: api
    tier: backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
      tier: backend
  template:
    metadata:
      labels:
        app: api
        tier: backend
    spec:
      containers:
      - name: api
        image: farajassulai/flask-python-app:production@sha256:c09decceba7dcf6521f453abb685fef457890d3ea3041c798f20001098696a7b
        env:
        - name: REDIS_HOST
          value: redis-service
        - name: REDIS_PORT
          value: "6379"
        - name: FLASK_ENV
          value: production
        ports:
        - containerPort: 5000
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5

---
# ----------------------------
# Redis Service
# ----------------------------
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  labels:
    app: redis
    tier: cache
spec:
  selector:
    app: redis
    tier: cache
  ports:
  - port: 6379
    targetPort: 6379
  type: ClusterIP

---
# ----------------------------
# API Service
# ----------------------------
apiVersion: v1
kind: Service
metadata:
  name: api-service
  labels:
    app: api
    tier: backend
spec:
  selector:
    app: api
    tier: backend
  ports:
  - port: 80
    targetPort: 5000
  type: LoadBalancer

```

**Deploy and Test the API:**
```bash
# Deploy the API and Redis
kubectl apply --filename api-with-cache.yaml

# Wait for deployments to be ready
kubectl wait --for=condition=available deployment/redis-deployment --timeout=300s
kubectl wait --for=condition=available deployment/api-deployment --timeout=300s

# Check deployment status
kubectl get deployments
kubectl get pods

# Test the API
kubectl port-forward service/api-service 8080:80

# Test cache miss (first request)
curl http://localhost:8080/api/users/1

# Test cache hit (second request - should be faster)
curl http://localhost:8080/api/users/1

# Check cache statistics
curl http://localhost:8080/api/stats

# Load test to see caching in action
for i in {1..10}; do
  curl -s http://localhost:8080/api/users/$((1 + RANDOM % 5)) | jq '.cached'
done
```

---

## Part III: Intermediate Demos - Multi-Service Applications

### Demo 6: Microservices E-Commerce Platform

This comprehensive demo showcases a realistic microservices architecture with multiple interconnected services.

#### 6.1: Frontend Service
```yaml
# frontend-service.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-config
data:
  nginx.conf: |
    events {
        worker_connections 1024;
    }
    
    http {
        upstream product_service {
            server product-service:80;
        }
        
        upstream order_service {
            server order-service:80;
        }
        
        upstream user_service {
            server user-service:80;
        }
        
        server {
            listen 80;
            
            location / {
                root /usr/share/nginx/html;
                index index.html;
            }
            
            location /api/products {
                proxy_pass http://product_service;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
            }
            
            location /api/orders {
                proxy_pass http://order_service;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
            }
            
            location /api/users {
                proxy_pass http://user_service;
                proxy_set_header Host $host;
                proxy_set_header X-Real-IP $remote_addr;
            }
            
            location /health {
                access_log off;
                return 200 "healthy\n";
                add_header Content-Type text/plain;
            }
        }
    }
    
  index.html: |
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>E-Commerce Platform</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
                background-color: #f5f5f5;
            }
            .header {
                background-color: #2c3e50;
                color: white;
                padding: 1rem;
                border-radius: 8px;
                margin-bottom: 2rem;
            }
            .service-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 1rem;
                margin-bottom: 2rem;
            }
            .service-card {
                background: white;
                padding: 1rem;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .api-test {
                background: white;
                padding: 1rem;
                border-radius: 8px;
                margin-top: 1rem;
            }
            button {
                background-color: #3498db;
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: 4px;
                cursor: pointer;
                margin: 0.25rem;
            }
            button:hover {
                background-color: #2980b9;
            }
            .response {
                background-color: #ecf0f1;
                padding: 1rem;
                border-radius: 4px;
                margin-top: 0.5rem;
                font-family: monospace;
                font-size: 12px;
                white-space: pre-wrap;
                max-height: 200px;
                overflow-y: auto;
            }
        </style>
    </head>
    <body>
        <div class="header">
            <h1>üõí Microservices E-Commerce Platform</h1>
            <p>Kubernetes Demo - Multi-Service Architecture</p>
        </div>
        
        <div class="service-grid">
            <div class="service-card">
                <h3>üõçÔ∏è Product Service</h3>
                <p>Manages product catalog, inventory, and pricing</p>
                <button onclick="testAPI('/api/products/health')">Health Check</button>
                <button onclick="testAPI('/api/products')">List Products</button>
            </div>
            
            <div class="service-card">
                <h3>üì¶ Order Service</h3>
                <p>Handles order processing and order history</p>
                <button onclick="testAPI('/api/orders/health')">Health Check</button>
                <button onclick="testAPI('/api/orders')">List Orders</button>
            </div>
            
            <div class="service-card">
                <h3>üë§ User Service</h3>
                <p>Manages user accounts and authentication</p>
                <button onclick="testAPI('/api/users/health')">Health Check</button>
                <button onclick="testAPI('/api/users')">List Users</button>
            </div>
        </div>
        
        <div class="api-test">
            <h3>API Test Console</h3>
            <div id="response" class="response">Click any button above to test the microservices...</div>
        </div>
        
        <script>
            async function testAPI(endpoint) {
                const responseDiv = document.getElementById('response');
                responseDiv.textContent = `Testing ${endpoint}...`;
                
                try {
                    const response = await fetch(endpoint);
                    const data = await response.json();
                    responseDiv.textContent = JSON.stringify(data, null, 2);
                } catch (error) {
                    responseDiv.textContent = `Error: ${error.message}`;
                }
            }
        </script>
    </body>
    </html>
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend-deployment
  labels:
    app: frontend
    tier: web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
        tier: web
    spec:
      containers:
      - name: nginx
        image: nginx:1.21-alpine
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"
        volumeMounts:
        - name: frontend-config
          mountPath: /etc/nginx/nginx.conf
          subPath: nginx.conf
        - name: frontend-config
          mountPath: /usr/share/nginx/html/index.html
          subPath: index.html
        livenessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 80
          initialDelaySeconds: 5
          periodSeconds: 5
      volumes:
      - name: frontend-config
        configMap:
          name: frontend-config
---
apiVersion: v1
kind: Service
metadata:
  name: frontend-service
spec:
  selector:
    app: frontend
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer

---
# product-service.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: product-service-config
data:
  app.py: |
    from flask import Flask, jsonify, request
    import json
    import uuid
    from datetime import datetime
    import os

    app = Flask(__name__)

    # In-memory product database (in production, use a real database)
    products = {
        "1": {"id": "1", "name": "Laptop", "price": 999.99, "category": "Electronics", "stock": 50},
        "2": {"id": "2", "name": "Phone", "price": 699.99, "category": "Electronics", "stock": 100},
        "3": {"id": "3", "name": "Book", "price": 19.99, "category": "Books", "stock": 200},
        "4": {"id": "4", "name": "Chair", "price": 149.99, "category": "Furniture", "stock": 25},
        "5": {"id": "5", "name": "Desk", "price": 299.99, "category": "Furniture", "stock": 15}
    }

    @app.route('/health')
    def health():
        return jsonify({
            'status': 'healthy',
            'service': 'product-service',
            'timestamp': datetime.now().isoformat(),
            'version': '1.0.0'
        })

    @app.route('/api/products', methods=['GET'])
    def get_products():
        category = request.args.get('category')
        if category:
            filtered_products = {k: v for k, v in products.items() if v['category'].lower() == category.lower()}
        else:
            filtered_products = products
            
        return jsonify({
            'products': list(filtered_products.values()),
            'total': len(filtered_products),
            'timestamp': datetime.now().isoformat()
        })

    @app.route('/api/products/<product_id>', methods=['GET'])
    def get_product(product_id):
        product = products.get(product_id)
        if product:
            return jsonify(product)
        return jsonify({'error': 'Product not found'}), 404

    @app.route('/api/products/<product_id>/stock', methods=['PUT'])
    def update_stock(product_id):
        product = products.get(product_id)
        if not product:
            return jsonify({'error': 'Product not found'}), 404
            
        data = request.get_json()
        if 'stock' in data:
            products[product_id]['stock'] = data['stock']
            return jsonify(products[product_id])
            
        return jsonify({'error': 'Stock value required'}), 400

    @app.route('/api/products/categories', methods=['GET'])
    def get_categories():
        categories = list(set(product['category'] for product in products.values()))
        return jsonify({
            'categories': categories,
            'timestamp': datetime.now().isoformat()
        })

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000, debug=False)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: product-service-deployment
  labels:
    app: product-service
    tier: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: product-service
  template:
    metadata:
      labels:
        app: product-service
        tier: backend
    spec:
      containers:
      - name: product-service
        # Using your custom Flask image
        image: farajassulai/flask-python-app:production@sha256:c09decceba7dcf6521f453abb685fef457890d3ea3041c798f20001098696a7b
        env:
        - name: SERVICE_NAME
          value: "product-service"
        - name: FLASK_APP
          value: "app.py"
        ports:
        - containerPort: 5000
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        volumeMounts:
        - name: service-code
          mountPath: /app/app.py
          subPath: app.py
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: service-code
        configMap:
          name: product-service-config
---
apiVersion: v1
kind: Service
metadata:
  name: product-service
spec:
  selector:
    app: product-service
  ports:
  - port: 80
    targetPort: 5000
  type: ClusterIP

---
# order-service.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: order-service-config
data:
  app.py: |
    from flask import Flask, jsonify, request
    import json
    import uuid
    from datetime import datetime
    import os

    app = Flask(__name__)

    # In-memory order database
    orders = {}

    def get_product_service_url():
        return os.getenv('PRODUCT_SERVICE_URL', 'http://product-service')

    @app.route('/health')
    def health():
        return jsonify({
            'status': 'healthy',
            'service': 'order-service',
            'timestamp': datetime.now().isoformat(),
            'version': '1.0.0'
        })

    @app.route('/api/orders', methods=['GET'])
    def get_orders():
        user_id = request.args.get('user_id')
        if user_id:
            user_orders = {k: v for k, v in orders.items() if v['user_id'] == user_id}
        else:
            user_orders = orders
            
        return jsonify({
            'orders': list(user_orders.values()),
            'total': len(user_orders),
            'timestamp': datetime.now().isoformat()
        })

    @app.route('/api/orders', methods=['POST'])
    def create_order():
        data = request.get_json()
        
        if not data or 'user_id' not in data or 'items' not in data:
            return jsonify({'error': 'user_id and items are required'}), 400

        order_id = str(uuid.uuid4())
        total_amount = 0
        
        # Calculate total (in production, verify with product service)
        for item in data['items']:
            total_amount += item.get('price', 0) * item.get('quantity', 1)

        order = {
            'id': order_id,
            'user_id': data['user_id'],
            'items': data['items'],
            'total_amount': total_amount,
            'status': 'pending',
            'created_at': datetime.now().isoformat(),
            'updated_at': datetime.now().isoformat()
        }
        
        orders[order_id] = order
        
        return jsonify(order), 201

    @app.route('/api/orders/<order_id>', methods=['GET'])
    def get_order(order_id):
        order = orders.get(order_id)
        if order:
            return jsonify(order)
        return jsonify({'error': 'Order not found'}), 404

    @app.route('/api/orders/<order_id>/status', methods=['PUT'])
    def update_order_status(order_id):
        order = orders.get(order_id)
        if not order:
            return jsonify({'error': 'Order not found'}), 404
            
        data = request.get_json()
        if 'status' in data:
            orders[order_id]['status'] = data['status']
            orders[order_id]['updated_at'] = datetime.now().isoformat()
            return jsonify(orders[order_id])
            
        return jsonify({'error': 'Status value required'}), 400

    @app.route('/api/orders/stats', methods=['GET'])
    def get_order_stats():
        total_orders = len(orders)
        total_amount = sum(order['total_amount'] for order in orders.values())
        status_counts = {}
        
        for order in orders.values():
            status = order['status']
            status_counts[status] = status_counts.get(status, 0) + 1
            
        return jsonify({
            'total_orders': total_orders,
            'total_amount': total_amount,
            'status_breakdown': status_counts,
            'timestamp': datetime.now().isoformat()
        })

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000, debug=False)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: order-service-deployment
  labels:
    app: order-service
    tier: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: order-service
  template:
    metadata:
      labels:
        app: order-service
        tier: backend
    spec:
      containers:
      - name: order-service
        # Using your custom Flask image
        image: farajassulai/flask-python-app:production@sha256:c09decceba7dcf6521f453abb685fef457890d3ea3041c798f20001098696a7b
        env:
        - name: SERVICE_NAME
          value: "order-service"
        - name: PRODUCT_SERVICE_URL
          value: "http://product-service"
        - name: FLASK_APP
          value: "app.py"
        ports:
        - containerPort: 5000
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        volumeMounts:
        - name: service-code
          mountPath: /app/app.py
          subPath: app.py
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: service-code
        configMap:
          name: order-service-config
---
apiVersion: v1
kind: Service
metadata:
  name: order-service
spec:
  selector:
    app: order-service
  ports:
  - port: 80
    targetPort: 5000
  type: ClusterIP

---
# user-service.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: user-service-config
data:
  app.py: |
    from flask import Flask, jsonify, request
    import json
    import uuid
    from datetime import datetime
    import os

    app = Flask(__name__)

    # In-memory user database
    users = {
        "1": {"id": "1", "username": "alice", "email": "alice@example.com", "created_at": "2023-01-01T00:00:00"},
        "2": {"id": "2", "username": "bob", "email": "bob@example.com", "created_at": "2023-01-15T00:00:00"},
        "3": {"id": "3", "username": "charlie", "email": "charlie@example.com", "created_at": "2023-02-01T00:00:00"}
    }

    @app.route('/health')
    def health():
        return jsonify({
            'status': 'healthy',
            'service': 'user-service',
            'timestamp': datetime.now().isoformat(),
            'version': '1.0.0'
        })

    @app.route('/api/users', methods=['GET'])
    def get_users():
        return jsonify({
            'users': list(users.values()),
            'total': len(users),
            'timestamp': datetime.now().isoformat()
        })

    @app.route('/api/users/<user_id>', methods=['GET'])
    def get_user(user_id):
        user = users.get(user_id)
        if user:
            return jsonify(user)
        return jsonify({'error': 'User not found'}), 404

    @app.route('/api/users', methods=['POST'])
    def create_user():
        data = request.get_json()
        
        if not data or 'username' not in data or 'email' not in data:
            return jsonify({'error': 'username and email are required'}), 400

        # Check if username already exists
        for user in users.values():
            if user['username'] == data['username']:
                return jsonify({'error': 'Username already exists'}), 409

        user_id = str(len(users) + 1)
        user = {
            'id': user_id,
            'username': data['username'],
            'email': data['email'],
            'created_at': datetime.now().isoformat()
        }
        
        users[user_id] = user
        
        return jsonify(user), 201

    @app.route('/api/users/<user_id>', methods=['PUT'])
    def update_user(user_id):
        user = users.get(user_id)
        if not user:
            return jsonify({'error': 'User not found'}), 404
            
        data = request.get_json()
        if 'email' in data:
            users[user_id]['email'] = data['email']
        if 'username' in data:
            users[user_id]['username'] = data['username']
            
        users[user_id]['updated_at'] = datetime.now().isoformat()
        return jsonify(users[user_id])

    @app.route('/api/users/stats', methods=['GET'])
    def get_user_stats():
        total_users = len(users)
        
        return jsonify({
            'total_users': total_users,
            'timestamp': datetime.now().isoformat()
        })

    if __name__ == '__main__':
        app.run(host='0.0.0.0', port=5000, debug=False)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: user-service-deployment
  labels:
    app: user-service
    tier: backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: user-service
  template:
    metadata:
      labels:
        app: user-service
        tier: backend
    spec:
      containers:
      - name: user-service
        # Using your custom Flask image
        image: farajassulai/flask-python-app:production@sha256:c09decceba7dcf6521f453abb685fef457890d3ea3041c798f20001098696a7b
        env:
        - name: SERVICE_NAME
          value: "user-service"
        - name: FLASK_APP
          value: "app.py"
        ports:
        - containerPort: 5000
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        volumeMounts:
        - name: service-code
          mountPath: /app/app.py
          subPath: app.py
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 5
      volumes:
      - name: service-code
        configMap:
          name: user-service-config
---
apiVersion: v1
kind: Service
metadata:
  name: user-service
spec:
  selector:
    app: user-service
  ports:
  - port: 80
    targetPort: 5000
  type: ClusterIP

**Deploy the Complete E-Commerce Platform:**
```bash
# Create a namespace for the e-commerce platform
kubectl create namespace ecommerce

# Deploy all services
kubectl apply -f frontend-service.yaml -n ecommerce
kubectl apply -f product-service.yaml -n ecommerce
kubectl apply -f order-service.yaml -n ecommerce
kubectl apply -f user-service.yaml -n ecommerce

# Monitor deployment progress
kubectl get deployments -n ecommerce -w

# Check all services are running
kubectl get all -n ecommerce

# Access the frontend
kubectl port-forward service/frontend-service 8080:80 -n ecommerce

# Open http://localhost:8080 in your browser
```

**Test the Microservices Integration:**
```bash
# Test product service directly
kubectl port-forward service/product-service 8081:80 -n ecommerce &
curl http://localhost:8081/api/products

# Test order service
kubectl port-forward service/order-service 8082:80 -n ecommerce &
curl -X POST http://localhost:8082/api/orders \
  -H "Content-Type: application/json" \
  -d '{
    "user_id": "1",
    "items": [
      {"id": "1", "name": "Laptop", "price": 999.99, "quantity": 1},
      {"id": "2", "name": "Phone", "price": 699.99, "quantity": 1}
    ]
  }'

# Test user service
kubectl port-forward service/user-service 8083:80 -n ecommerce &
curl http://localhost:8083/api/users
```

### Demo 7: Monitoring and Logging Stack

This demo shows how to set up comprehensive monitoring for your applications.

#### 7.1: Prometheus Monitoring Setup
```yaml
# prometheus-deployment.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: prometheus-config
data:
  prometheus.yml: |
    global:
      scrape_interval: 15s
      evaluation_interval: 15s

    rule_files:
      - "rules.yml"

    scrape_configs:
      - job_name: 'kubernetes-pods'
        kubernetes_sd_configs:
          - role: pod
        relabel_configs:
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]
            action: keep
            regex: true
          - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]
            action: replace
            target_label: __metrics_path__
            regex: (.+)
          - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]
            action: replace
            regex: ([^:]+)(?::\d+)?;(\d+)
            replacement: ${1}:${2}
            target_label: __address__

      - job_name: 'kubernetes-nodes'
        kubernetes_sd_configs:
          - role: node
        relabel_configs:
          - action: labelmap
            regex: __meta_kubernetes_node_label_(.+)

  rules.yml: |
    groups:
      - name: kubernetes
        rules:
          - alert: PodCrashLooping
            expr: rate(kube_pod_container_status_restarts_total[15m]) > 0
            for: 5m
            labels:
              severity: warning
            annotations:
              summary: "Pod {{ $labels.pod }} is crash looping"
              description: "Pod {{ $labels.pod }} in namespace {{ $labels.namespace }} is restarting frequently"

          - alert: HighMemoryUsage
            expr: (container_memory_working_set_bytes / container_spec_memory_limit_bytes) > 0.8
            for: 5m
            labels:
              severity: warning
            annotations:
              summary: "High memory usage detected"
              description: "Container {{ $labels.container }} in pod {{ $labels.pod }} is using more than 80% of its memory limit"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: prometheus-deployment
  labels:
    app: prometheus
spec:
  replicas: 1
  selector:
    matchLabels:
      app: prometheus
  template:
    metadata:
      labels:
        app: prometheus
    spec:
      serviceAccountName: prometheus
      containers:
      - name: prometheus
        image: prom/prometheus:v2.40.0
        args:
          - '--config.file=/etc/prometheus/prometheus.yml'
          - '--storage.tsdb.path=/prometheus'
          - '--web.console.libraries=/etc/prometheus/console_libraries'
          - '--web.console.templates=/etc/prometheus/consoles'
          - '--web.enable-lifecycle'
        ports:
        - containerPort: 9090
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: config-volume
          mountPath: /etc/prometheus/
        - name: storage-volume
          mountPath: /prometheus
      volumes:
      - name: config-volume
        configMap:
          name: prometheus-config
      - name: storage-volume
        emptyDir: {}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: prometheus
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: prometheus
rules:
- apiGroups: [""]
  resources: ["nodes", "pods", "services", "endpoints"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: prometheus
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: prometheus
subjects:
- kind: ServiceAccount
  name: prometheus
  namespace: default
---
apiVersion: v1
kind: Service
metadata:
  name: prometheus-service
spec:
  selector:
    app: prometheus
  ports:
  - port: 9090
    targetPort: 9090
  type: NodePort
```

#### 7.2: Grafana Dashboard Setup
```yaml
# grafana-deployment.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: grafana-config
data:
  grafana.ini: |
    [analytics]
    check_for_updates = true
    [grafana_net]
    url = https://grafana.net
    [log]
    mode = console
    [paths]
    data = /var/lib/grafana/
    logs = /var/log/grafana
    plugins = /var/lib/grafana/plugins
    provisioning = /etc/grafana/provisioning

  datasources.yml: |
    apiVersion: 1
    datasources:
      - name: Prometheus
        type: prometheus
        url: http://prometheus-service:9090
        access: proxy
        isDefault: true

  dashboards.yml: |
    apiVersion: 1
    providers:
      - name: 'default'
        orgId: 1
        folder: ''
        type: file
        disableDeletion: false
        updateIntervalSeconds: 10
        allowUiUpdates: true
        options:
          path: /var/lib/grafana/dashboards

  kubernetes-dashboard.json: |
    {
      "dashboard": {
        "id": null,
        "title": "Kubernetes Cluster Overview",
        "tags": ["kubernetes"],
        "style": "dark",
        "timezone": "browser",
        "panels": [
          {
            "id": 1,
            "title": "Pod Status",
            "type": "stat",
            "targets": [
              {
                "expr": "kube_pod_status_phase{phase=\"Running\"}",
                "legendFormat": "Running Pods"
              }
            ],
            "gridPos": {"h": 8, "w": 12, "x": 0, "y": 0}
          },
          {
            "id": 2,
            "title": "CPU Usage",
            "type": "graph",
            "targets": [
              {
                "expr": "sum(rate(container_cpu_usage_seconds_total[5m])) by (pod)",
                "legendFormat": "{{pod}}"
              }
            ],
            "gridPos": {"h": 8, "w": 12, "x": 12, "y": 0}
          }
        ],
        "time": {"from": "now-1h", "to": "now"},
        "refresh": "5s"
      }
    }
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: grafana-deployment
  labels:
    app: grafana
spec:
  replicas: 1
  selector:
    matchLabels:
      app: grafana
  template:
    metadata:
      labels:
        app: grafana
    spec:
      containers:
      - name: grafana
        image: grafana/grafana:9.3.0
        ports:
        - containerPort: 3000
        env:
        - name: GF_SECURITY_ADMIN_PASSWORD
          value: "admin123"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "200m"
        volumeMounts:
        - name: grafana-config
          mountPath: /etc/grafana/grafana.ini
          subPath: grafana.ini
        - name: grafana-config
          mountPath: /etc/grafana/provisioning/datasources/datasources.yml
          subPath: datasources.yml
        - name: grafana-config
          mountPath: /etc/grafana/provisioning/dashboards/dashboards.yml
          subPath: dashboards.yml
        - name: grafana-dashboards
          mountPath: /var/lib/grafana/dashboards
        - name: grafana-storage
          mountPath: /var/lib/grafana
      volumes:
      - name: grafana-config
        configMap:
          name: grafana-config
      - name: grafana-dashboards
        configMap:
          name: grafana-config
      - name: grafana-storage
        emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: grafana-service
spec:
  selector:
    app: grafana
  ports:
  - port: 3000
    targetPort: 3000
  type: NodePort
```

**Deploy Monitoring Stack:**
```bash
# Deploy Prometheus and Grafana
kubectl apply -f prometheus-deployment.yaml
kubectl apply -f grafana-deployment.yaml

# Wait for deployments
kubectl wait --for=condition=available deployment/prometheus-deployment --timeout=300s
kubectl wait --for=condition=available deployment/grafana-deployment --timeout=300s

# Access Prometheus
kubectl port-forward service/prometheus-service 9090:9090 &

# Access Grafana (admin/admin123)
kubectl port-forward service/grafana-service 3000:3000 &

# Open http://localhost:9090 for Prometheus
# Open http://localhost:3000 for Grafana
```

---

