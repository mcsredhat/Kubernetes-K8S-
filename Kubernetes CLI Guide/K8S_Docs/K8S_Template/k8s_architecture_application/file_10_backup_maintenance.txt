# ============================================================================
# 10-backup-maintenance.yaml - Backup, Snapshots and Maintenance (FULLY CORRECTED)
# ============================================================================
# Purpose: Automated backup, data snapshots, and maintenance operations
# Dependencies: CSI driver with snapshot support, storage classes must exist
# Features: Volume snapshots, automated backups, restoration procedures
# ALL CRITICAL FIXES APPLIED:
# - Updated CronJob from deprecated batch/v1beta1 to batch/v1
# - Fixed timeZone field placement to correct location in CronJob spec
# - Corrected volume configurations in backup jobs
# - Fixed all deprecated fields in CronJob specification
# - Added proper resource limits and security contexts
# ============================================================================

# Volume Snapshot Class - Defines how to create snapshots
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: {{APP_NAME}}-snapshot-class
  labels:
    app: {{APP_NAME}}
    app.kubernetes.io/component: backup
    app.kubernetes.io/part-of: {{APP_NAME}}
  annotations:
    description: "Snapshot class for {{APP_NAME}} backups"
    snapshot.storage.kubernetes.io/is-default-class: "false"
driver: ebs.csi.aws.com  # Change to your CSI driver (e.g., pd.csi.storage.gke.io for GCP)
deletionPolicy: Delete
parameters:
  # AWS EBS parameters
  encrypted: "true"
  # GCP PD parameters (uncomment if using GCP)
  # storage-locations: us-central1

---
# Manual Volume Snapshot - One-time backup
apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: {{APP_NAME}}-manual-snapshot
  namespace: {{NAMESPACE}}
  labels:
    app: {{APP_NAME}}
    app.kubernetes.io/component: backup
    app.kubernetes.io/part-of: {{APP_NAME}}
    backup-type: manual
  annotations:
    description: "Manual snapshot of {{APP_NAME}} data volume"
    created-by: "k8s-template"
    backup-date: "REPLACE_WITH_ACTUAL_DATE"
spec:
  volumeSnapshotClassName: {{APP_NAME}}-snapshot-class
  source:
    persistentVolumeClaimName: {{APP_NAME}}-data-pvc

---
# CORRECTED: Updated CronJob to current API version with proper field placement
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{APP_NAME}}-backup
  namespace: {{NAMESPACE}}
  labels:
    app: {{APP_NAME}}
    app.kubernetes.io/name: {{APP_NAME}}
    app.kubernetes.io/component: backup
    app.kubernetes.io/part-of: {{APP_NAME}}
  annotations:
    description: "Automated backup job for {{APP_NAME}} application data"
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM UTC
  timeZone: "UTC"  # CORRECTED: Moved to correct location in CronJob spec
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  concurrencyPolicy: Forbid
  startingDeadlineSeconds: 3600
  jobTemplate:
    spec:
      activeDeadlineSeconds: 3600  # 1 hour timeout
      backoffLimit: 2
      template:
        metadata:
          labels:
            app: {{APP_NAME}}-backup
            app.kubernetes.io/component: backup
            app.kubernetes.io/part-of: {{APP_NAME}}
        spec:
          restartPolicy: OnFailure
          # CORRECTED: Added proper security context
          securityContext:
            runAsNonRoot: true
            runAsUser: 65534
            runAsGroup: 65534
            fsGroup: 65534
          containers:
          - name: backup
            image: busybox:1.36
            command:
            - /bin/sh
            - -c
            - |
              set -e
              
              BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
              BACKUP_DIR="/backup/${BACKUP_DATE}"
              
              echo "=== {{APP_NAME}} Backup Started at $(date -Iseconds) ==="
              echo "Backup directory: ${BACKUP_DIR}"
              echo "Environment: {{ENVIRONMENT}}"
              echo "Namespace: {{NAMESPACE}}"
              
              # Create backup directory
              mkdir -p "${BACKUP_DIR}"
              
              # Backup application data
              echo "Backing up application data..."
              if [ -d "/data" ] && [ "$(ls -A /data)" ]; then
                tar -czf "${BACKUP_DIR}/app-data.tar.gz" -C /data .
                echo "Application data backup completed: $(ls -lh ${BACKUP_DIR}/app-data.tar.gz)"
              else
                echo "Warning: /data directory is empty or not found"
                touch "${BACKUP_DIR}/no-data-found"
              fi
              
              # Create backup metadata
              cat > "${BACKUP_DIR}/backup-info.json" << EOF
              {
                "app": "{{APP_NAME}}",
                "environment": "{{ENVIRONMENT}}",
                "namespace": "{{NAMESPACE}}", 
                "backup_date": "${BACKUP_DATE}",
                "backup_timestamp": "$(date -Iseconds)",
                "backup_type": "automated",
                "storage_size": "{{STORAGE_SIZE}}",
                "files": [
                  "app-data.tar.gz"
                ]
              }
              EOF
              
              # Calculate checksums if data exists
              echo "Calculating checksums..."
              cd "${BACKUP_DIR}"
              if [ -f "app-data.tar.gz" ]; then
                sha256sum app-data.tar.gz > checksums.sha256
              fi
              
              # Cleanup old backups (keep last 7 days)
              echo "Cleaning up old backups..."
              find /backup -name "20*" -type d -mtime +7 -exec rm -rf {} + 2>/dev/null || true
              
              # Show backup summary
              echo "=== Backup Summary ==="
              echo "Total backup size: $(du -sh ${BACKUP_DIR} | cut -f1)"
              echo "Files created:"
              ls -la "${BACKUP_DIR}"
              echo "=== Backup completed successfully at $(date -Iseconds) ==="
            
            volumeMounts:
            - name: app-data
              mountPath: /data
              readOnly: true
            - name: backup-storage
              mountPath: /backup
            
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
                ephemeral-storage: "1Gi"
              limits:
                memory: "256Mi"
                cpu: "200m"
                ephemeral-storage: "2Gi"
            
            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: true
              capabilities:
                drop: ["ALL"]
          
          # CORRECTED: Fixed volume configuration
          volumes:
          - name: app-data
            persistentVolumeClaim:
              claimName: {{APP_NAME}}-data-pvc
          - name: backup-storage
            emptyDir:
              sizeLimit: 5Gi
              # In production, use persistent backup storage:
              # persistentVolumeClaim:
              #   claimName: {{APP_NAME}}-backup-pvc

---
# CORRECTED: Data Restoration Job Template - current API version
apiVersion: batch/v1
kind: Job
metadata:
  name: {{APP_NAME}}-restore
  namespace: {{NAMESPACE}}
  labels:
    app: {{APP_NAME}}
    app.kubernetes.io/component: restore
    app.kubernetes.io/part-of: {{APP_NAME}}
  annotations:
    description: "Data restoration job for {{APP_NAME}} - customize before use"
    restore.backup-date: "SPECIFY_BACKUP_DATE"
    restore.source: "SPECIFY_SOURCE_LOCATION"
spec:
  activeDeadlineSeconds: 3600
  backoffLimit: 1
  template:
    metadata:
      labels:
        app: {{APP_NAME}}-restore
        app.kubernetes.io/component: restore
    spec:
      restartPolicy: Never
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        runAsGroup: 65534
        fsGroup: 65534
      containers:
      - name: restore
        image: busybox:1.36
        command:
        - /bin/sh
        - -c
        - |
          set -e
          
          echo "=== {{APP_NAME}} Data Restoration Started ==="
          echo "IMPORTANT: This job must be customized before use!"
          echo "Timestamp: $(date -Iseconds)"
          
          # CUSTOMIZE: Add your restoration logic here
          # Example restoration steps:
          
          # 1. Verify backup exists and is valid
          # BACKUP_DATE="20250101_020000"  # Set your backup date
          # if [ ! -f "/backup/${BACKUP_DATE}/app-data.tar.gz" ]; then
          #   echo "ERROR: Backup file not found"
          #   exit 1
          # fi
          
          # 2. Verify checksums
          # cd /backup/${BACKUP_DATE}
          # sha256sum -c checksums.sha256 || exit 1
          
          # 3. Stop application (scale down deployment)
          # kubectl scale deployment {{APP_NAME}}-deployment --replicas=0 -n {{NAMESPACE}}
          
          # 4. Restore data
          # cd /data
          # tar -xzf /backup/${BACKUP_DATE}/app-data.tar.gz
          
          # 5. Set proper permissions
          # chown -R 101:101 /data
          
          # 6. Start application (scale up deployment)
          # kubectl scale deployment {{APP_NAME}}-deployment --replicas=3 -n {{NAMESPACE}}
          
          echo "=== Restoration template completed ==="
          echo "Please customize this job for your specific restoration needs"
        
        volumeMounts:
        - name: app-data
          mountPath: /data
        - name: backup-source
          mountPath: /backup
          readOnly: true
        
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop: ["ALL"]
      
      # CORRECTED: Fixed volume configuration
      volumes:
      - name: app-data
        persistentVolumeClaim:
          claimName: {{APP_NAME}}-data-pvc
      - name: backup-source
        emptyDir: {}
        # CUSTOMIZE: Point to your actual backup storage
        # persistentVolumeClaim:
        #   claimName: {{APP_NAME}}-backup-pvc

---
# Maintenance Window Job - CORRECTED
apiVersion: batch/v1
kind: Job
metadata:
  name: {{APP_NAME}}-maintenance
  namespace: {{NAMESPACE}}
  labels:
    app: {{APP_NAME}}
    app.kubernetes.io/component: maintenance
    app.kubernetes.io/part-of: {{APP_NAME}}
  annotations:
    description: "Maintenance operations job - customize before use"
spec:
  activeDeadlineSeconds: 7200  # 2 hours
  backoffLimit: 1
  template:
    metadata:
      labels:
        app: {{APP_NAME}}-maintenance
        app.kubernetes.io/component: maintenance
    spec:
      restartPolicy: Never
      securityContext:
        runAsNonRoot: true
        runAsUser: 65534
        runAsGroup: 65534
        fsGroup: 65534
      containers:
      - name: maintenance
        image: busybox:1.36
        command:
        - /bin/sh
        - -c
        - |
          echo "=== Maintenance Operations Started ==="
          echo "Timestamp: $(date -Iseconds)"
          echo "Add your maintenance tasks here:"
          echo "- Database migrations"
          echo "- Cache clearing"
          echo "- Log rotation"
          echo "- Health checks"
          echo "- Performance optimization"
          
          # Example maintenance tasks:
          echo "Clearing old logs..."
          find /data/logs -name "*.log" -mtime +7 -delete 2>/dev/null || true
          
          echo "Creating maintenance report..."
          cat > /data/maintenance-report-$(date +%Y%m%d).txt << EOF
          Maintenance Report - $(date -Iseconds)
          Application: {{APP_NAME}}
          Environment: {{ENVIRONMENT}}
          Namespace: ${NAMESPACE}
          
          Tasks Completed:
          - Log cleanup completed
          - Disk space check completed
          - Health status verified
          
          System Status: OK
          EOF
          
          echo "=== Maintenance completed successfully ==="
        env:
        - name: NAMESPACE
          value: "{{NAMESPACE}}"
        - name: APP_NAME
          value: "{{APP_NAME}}"
        volumeMounts:
        - name: app-data
          mountPath: /data
          readOnly: false
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop: ["ALL"]
      volumes:
      - name: app-data
        persistentVolumeClaim:
          claimName: {{APP_NAME}}-data-pvc

---
# Backup Storage PVC - CORRECTED
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: {{APP_NAME}}-backup-pvc
  namespace: {{NAMESPACE}}
  labels:
    app: {{APP_NAME}}
    app.kubernetes.io/component: backup-storage
    app.kubernetes.io/part-of: {{APP_NAME}}
  annotations:
    description: "Persistent storage for {{APP_NAME}} backups"
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: {{STORAGE_CLASS}}-aws  # Use your backup storage class
  resources:
    requests:
      storage: 50Gi

---
# Volume Snapshot CronJob - CORRECTED: Automated snapshot creation
apiVersion: batch/v1
kind: CronJob
metadata:
  name: {{APP_NAME}}-snapshot
  namespace: {{NAMESPACE}}
  labels:
    app: {{APP_NAME}}
    app.kubernetes.io/component: backup
spec:
  schedule: "0 1 * * 0"  # Weekly on Sunday at 1 AM
  timeZone: "UTC"
  successfulJobsHistoryLimit: 2
  failedJobsHistoryLimit: 1
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      activeDeadlineSeconds: 1800  # 30 minutes
      template:
        spec:
          restartPolicy: OnFailure
          serviceAccountName: {{APP_NAME}}-sa
          containers:
          - name: snapshot-creator
            image: bitnami/kubectl:latest
            command:
            - /bin/bash
            - -c
            - |
              SNAPSHOT_NAME="{{APP_NAME}}-auto-$(date +%Y%m%d-%H%M%S)"
              
              cat <<EOF | kubectl apply -f -
              apiVersion: snapshot.storage.k8s.io/v1
              kind: VolumeSnapshot
              metadata:
                name: ${SNAPSHOT_NAME}
                namespace: {{NAMESPACE}}
                labels:
                  app: {{APP_NAME}}
                  backup-type: automated
                annotations:
                  created-by: "snapshot-cronjob"
                  backup-date: "$(date -Iseconds)"
              spec:
                volumeSnapshotClassName: {{APP_NAME}}-snapshot-class
                source:
                  persistentVolumeClaimName: {{APP_NAME}}-data-pvc
              EOF
              
              echo "Created snapshot: ${SNAPSHOT_NAME}"
              
              # Cleanup old automated snapshots (keep last 4)
              kubectl get volumesnapshots -n {{NAMESPACE}} \
                -l backup-type=automated \
                --sort-by=.metadata.creationTimestamp \
                -o name | head -n -4 | xargs -r kubectl delete -n {{NAMESPACE}}
            resources:
              requests:
                memory: "64Mi"
                cpu: "50m"
              limits:
                memory: "128Mi"
                cpu: "100m"