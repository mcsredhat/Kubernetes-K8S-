## kubectl CLI Reference Summary
This comprehensive reference organizes all the kubectl commands covered in this guide, serving as your quick-access handbook for Kubernetes operations. Think of this as your operational cheat sheet that you can reference during real-world troubleshooting and management tasks.
### Essential Configuration and Setup
Understanding how to properly configure kubectl forms the foundation of efficient Kubernetes management. These commands help you establish your working environment and create shortcuts that will save you countless hours of typing.
# Configure kubectl context and namespace management
kubectl config current-context                    # Display current context
kubectl config get-contexts                       # List all available contexts
kubectl config use-context <context-name>         # Switch between contexts
kubectl config set-context --current --namespace=<namespace>  # Set default namespace
kubectl config view                               # View current configuration
kubectl config view --minify                     # View current context only

# Create custom contexts for different environments
kubectl config set-context learning --cluster=<cluster> --user=<user> --namespace=learning

# Essential aliases for productivity (add to ~/.bashrc or ~/.zshrc)
alias k=kubectl
alias kgp='kubectl get pods'
alias kgs='kubectl get svc'  
alias kgd='kubectl get deployments'
alias kdp='kubectl describe pod'
alias kdd='kubectl describe deployment'
alias kaf='kubectl apply -f'
alias kdel='kubectl delete'

# Enable kubectl autocompletion
source <(kubectl completion bash)    # For bash users
source <(kubectl completion zsh)     # For zsh users
complete -F __start_kubectl k        # Enable completion for 'k' alias

### Pod Management and Lifecycle Operations
Pods represent the fundamental unit of deployment in Kubernetes, and mastering their management is crucial for any Kubernetes operator. These commands cover everything from basic pod creation to advanced debugging scenarios.

# Pod creation and basic management
kubectl run <pod-name> --image=<image> --restart=Never    # Create a single pod
kubectl run <pod-name> --image=<image> --restart=Never --namespace=<namespace>
kubectl run <pod-name> --image=<image> --restart=Never --dry-run=client -o yaml > pod.yaml  # Generate pod YAML
kubectl run <pod-name> --image=<image> --restart=Never --namespace=<namespace> --dry-run=client -o yaml > pod.yaml 
kubectl run $APP_NAME \
  --image=<APP_IMAGE> \
  --port=<APP_PORT> \
  --restart=Never \
  --namespace=<APP_NAMESPACE> \
  --labels="app=<APP_NAME>,tier=<frontend>,version=1.0" \
  --annotations="description=<APP_NAME> pod" \
  --annotations="owner=<web-team>" \
  --env="<APP_PORT>" \
  --env="APP_HOST=<localhost>" \
  --dry-run=client \
  --output=yaml > <{APP_NAME}>-secure.yaml

kubectl apply --filename <filename.yaml>                # Apply pod configuration
kubectl delete pod <pod-name>                            # Delete specific pod
kubectl delete pod <pod-name> --namespace=<namespace> 
kubectl delete pods --all                                # Delete all pods in namespace

# Pod monitoring and status checking
kubectl get pods                           # List pods in current namespace
kubectl get pods -o wide                   # List pods with additional details (node, IP)
kubectl get pods --namespace=<namespace>
kubectl get pods --all-namespaces                        # List pods across all namespaces
kubectl get pods -w                                # Watch pod status changes in real-time
kubectl get pods --watch-only=true --output-watch-events # Watch with event timestamps
kubectl get pods --sort-by='.metadata.creationTimestamp' # Sort pods by creation time

# Advanced pod querying and filtering
kubectl get pods -l app=nginx                            # Filter pods by label
kubectl get pods -l 'environment in (production,staging)' # Multiple label values
kubectl get pods --field-selector=status.phase=Running   # Filter by field selector
kubectl get pods --field-selector=spec.nodeName!=worker-1 # Filter by node name
kubectl get pods --field-selector=status.phase!=Running  # Find non-running pods
kubectl get pods --field-selector=status.phase=Pending #Get pods that are Pending
kubectl get pods --field-selector=spec.nodeName="" #Get pods not yet assigned to any node
kubectl get jobs --field-selector=status.failed>0 # Get jobs that have failed
kubectl get pods --field-selector=status.phase=Succeeded #Get pods that have succeeded (completed batch jobs)
kubectl get pods --namespace default --field-selector=status.phase=Terminating           #Get pods in `default` namespace that are terminating
kubectl get nodes --field-selector=spec.unschedulable=true# Get nodes that are marked as unschedulable
kubectl get pods --field-selector=spec.serviceAccountName=default #Get pods owned by a specific service account.
kubectl get pods -o wide --field-selector=status.containerStatuses[0].restartCount>1
# Get pods restarted more than once (with wide output)

"-o custom-columns" (select fields into table-like output)
# 1. Show pod name and status
kubectl get pods --output custom-columns=NAME:.metadata.name,STATUS:.status.phase
# 2. Show pod name and its node
kubectl get pods --output custom-columns=NAME:.metadata.name,NODE:.spec.nodeName
# 3. Show pod name and namespace
kubectl get pods --output custom-columns=POD:.metadata.name,NAMESPACE:.metadata.namespace
# 4. Show pod name and creation timestamp
kubectl get pods --output custom-columns=NAME:.metadata.name,CREATED:.metadata.creationTimestamp
# 5. Show deployment name and replicas
kubectl get deployments --output custom-columns=DEPLOYMENT:.metadata.name,REPLICAS:.spec.replicas
# 6. Show service name and cluster IP
kubectl get services --output custom-columns=NAME:.metadata.name,CLUSTER-IP:.spec.clusterIP
# 7. Show pod name and labels
kubectl get pods --output custom-columns=NAME:.metadata.name,LABELS:.metadata.labels
# 8. Show ingress name and host
kubectl get ingress --output custom-columns=NAME:.metadata.name,HOST:.spec.rules[0].host
# 9. Show configmap name and namespace
kubectl get configmap --output custom-columns=NAME:.metadata.name,NAMESPACE:.metadata.namespace
# 10. Show node name and readiness condition
kubectl get nodes --output custom-columns=NODE:.metadata.name,READY:.status.conditions[-1]

"-o jsonpath=" (flexible field extraction)
# 1. Pod names only
kubectl get pods --output jsonpath='{.items[*].metadata.name}'
# 2. Pod names and their phases
kubectl get pods --output jsonpath='{range .items[*]}{.metadata.name}{" => "}{.status.phase}{"\n"}{end}'
# 3. Pod names and node names
kubectl get pods --output jsonpath='{range .items[*]}{.metadata.name}{" @ "}{.spec.nodeName}{"\n"}{end}'
# 4. Pod names with container images
kubectl get pods --output jsonpath='{range .items[*]}{.metadata.name}{" => "}{.spec.containers[*].image}{"\n"}{end}'
# 5. Deployment names with replicas (desired/ready)
kubectl get deployments --output jsonpath='{range .items[*]}{.metadata.name}{" "}{.spec.replicas}{"/"}{.status.readyReplicas}{"\n"}{end}'
# 6. Node names and readiness status
kubectl get nodes --output jsonpath='{range .items[*]}{.metadata.name}{" => "}{.status.conditions[?(@.type=="Ready")].status}{"\n"}{end}'
# 7. List all namespaces
kubectl get namespaces --output jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}'
# 8. List all service names and their ports
kubectl get services --output jsonpath='{range .items[*]}{.metadata.name}{" => "}{.spec.ports[*].port}{"\n"}{end}'
# 9. Pod names with restart count
kubectl get pods --output jsonpath='{range .items[*]}{.metadata.name}{" => "}{.status.containerStatuses[*].restartCount}{"\n"}{end}'
# 10. Show all node internal IPs
kubectl get nodes --output jsonpath='{range .items[*]}{.metadata.name}{" => "}{.status.addresses[?(@.type=="InternalIP")].address}{"\n"}{end}'

# Pod inspection and debugging
kubectl describe pod <pod-name>                    # Detailed pod information and events
kubectl logs <pod-name>                                 # View pod logs
kubectl logs <pod-name> -f                              # Follow logs in real-time
kubectl logs <pod-name> --previous              # View logs from previous container instance
kubectl logs <pod-name> --containers <container-name>   # Logs from specific container
kubectl logs -l app=nginx --tail=50                     # Logs from multiple pods by label

# Pod resource monitoring
kubectl top pod <pod-name>                              # Resource usage for specific pod
kubectl top pods --sort-by=memory                       # Sort pods by memory usage
kubectl top pods --sort-by=cpu                          # Sort pods by CPU usage
kubectl top pods -l app=nginx --containers         # Resource usage with container breakdown

# Pod execution and file operations
kubectl exec <pod-name> -- <command>                    # Execute command in pod
kubectl exec -it <pod-name> -- /bin/bash               # Interactive shell in pod
kubectl exec <pod-name> -c <container-name> -- <command> # Execute in specific container
kubectl cp <local-path> <pod-name>:<pod-path>          # Copy file to pod
kubectl cp <pod-name>:<pod-path> <local-path>          # Copy file from pod

# Multi-container pod operations
kubectl logs <pod-name> --container <container-name>   # Logs from specific container
kubectl exec <pod-name> --container <container-name> -it -- sh  # Shell into specific container
kubectl describe pod <pod-name> | grep -A 10 "Containers:" # List all containers in pod

### ReplicaSet and Scaling Operations
ReplicaSets ensure your applications maintain the desired number of running instances, providing the foundation for high availability. These commands help you understand and manage the scaling behavior that keeps your applications resilient.
# ReplicaSet management and monitoring
kubectl get replicasets                                 # List all ReplicaSets
kubectl get replicasets -o wide                     # ReplicaSets with additional details
kubectl get rs                                          # Shorthand for replicasets
kubectl describe replicaset <rs-name>                   # Detailed ReplicaSet information
kubectl get replicaset <rs-name> -o yaml               # ReplicaSet YAML configuration

# ReplicaSet scaling operations
kubectl scale replicaset <rs-name> --replicas=5         # Scale ReplicaSet directly
kubectl scale deployment <deployment-name> --replicas=3 # Scale via Deployment (recommended)
kubectl get replicaset -w                               # Watch ReplicaSet changes

# ReplicaSet status and health checking
kubectl get replicasets --output custom-columns=NAME:.metadata.name,DESIRED:.spec.replicas,CURRENT:.status.replicas,READY:.status.readyReplicas
kubectl get pods -l <replicaset-selector>             # View pods managed by ReplicaSet

# Understanding ReplicaSet relationships
kubectl get replicasets -l app=<app-name> --show-labels # Show labels used for pod selection
kubectl describe replicaset <rs-name> | grep "Pod Template" -A 20  # View pod template
kubectl get pods -l <selector> --output custom-columns=NAME:.metadata.name,OWNER:.metadata.ownerReferences[0].name # Show ownership

### Deployment Management and Updates
Deployments orchestrate rolling updates and provide rollback capabilities, making them essential for production application management. These commands cover the full lifecycle of deployment operations.

# Deployment creation and basic management
kubectl create deployment <name> --image=<image>         # Create deployment
kubectl create deployment <name> --image=<image> --replicas=3 # Create with replica count
kubectl apply --filename deployment.yaml                # Apply deployment from file
kubectl delete deployment <name>                        # Delete deployment

# Deployment monitoring and status
kubectl get deployments                                  # List all deployments
kubectl get deployments -o wide                         # Deployments with additional details
kubectl describe deployment <name>                      # Detailed deployment information
kubectl rollout status deployment/<name>                # Check rollout status
kubectl rollout status deployment/<name> --watch=true   # Watch rollout progress

# Deployment scaling operations
kubectl scale deployment <name> --replicas=5            # Scale deployment
kubectl autoscale deployment <name> --min=2 --max=10 --cpu-percent=70 # Enable autoscaling

# Deployment update operations
kubectl set image deployment/<name> <container-name>=<new-image> # Update container image
kubectl patch deployment <name> -p '{"spec":{"replicas":3}}'     # Patch deployment
kubectl edit deployment <name>                          # Edit deployment interactively

# Rolling update control
kubectl rollout pause deployment/<name>                 # Pause rollout
kubectl rollout resume deployment/<name>                # Resume paused rollout
kubectl rollout restart deployment/<name>               # Restart deployment (recreate pods)

# Rollback operations
kubectl rollout history deployment/<name>               # View rollout history
kubectl rollout history deployment/<name> --revision=2  # View specific revision details
kubectl rollout undo deployment/<name>                  # Rollback to previous revision
kubectl rollout undo deployment/<name> --to-revision=2  # Rollback to specific revision

# Deployment health and relationship monitoring
kubectl get deployment,replicaset,pods -l app=<name>    # View entire deployment hierarchy
kubectl get replicasets -l app=<name>                   # View ReplicaSets managed by deployment
kubectl describe deployment <name> | grep -A 10 Conditions # Check deployment conditions


### Resource Inspection and Custom Queries

Advanced querying capabilities allow you to extract specific information and monitor resources efficiently. These techniques are essential for automation and monitoring in production environments.
# Custom output formats for specific data extraction
kubectl get pods --output custom-columns=NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName,IP:.status.podIP
kubectl get deployments --output custom-columns=NAME:.metadata.name,READY:.status.readyReplicas/.spec.replicas,STRATEGY:.spec.strategy.type
kubectl get nodes --output custom-columns=NAME:.metadata.name,STATUS:.status.conditions[?(@.type==\"Ready\")].status,VERSION:.status.nodeInfo.kubeletVersion 

kubectl get pods --output custom-columns=NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName,IP:.status.podIP,PORT:.spec.containers[*].ports[*].containerPort,PROTOCOL:.spec.containers[*].ports[*].protocol


# JSONPath queries for precise data extraction
kubectl get pods --output jsonpath='{.items[*].metadata.name}'     # Pod names only
kubectl get pods --output jsonpath='{.items[*].status.podIP}'        # Pod IPs only
kubectl get deployment <name> --output jsonpath='{.spec.replicas}'   # Desired replica count
kubectl get deployment <name> --output jsonpath='{.status.readyReplicas}' # Ready replica count
kubectl get nodes --output jsonpath='{.items[*].status.addresses[?(@.type==\"InternalIP\")].address}' # Node internal IPs

# Complex filtering and sorting operations
kubectl get pods --sort-by='.status.startTime'              # Sort by start time
kubectl get pods --sort-by='.metadata.creationTimestamp'    # Sort by creation time
kubectl get events --sort-by='.lastTimestamp'               # Sort events by timestamp
kubectl get pods --field-selector=status.phase=Failed       # Find failed pods
kubectl get pods --field-selector=spec.restartPolicy=Always  # Filter by restart policy

# Resource relationships and ownership
kubectl get pods --output custom-columns=NAME:.metadata.name,OWNER:.metadata.ownerReferences[0].name,OWNER-KIND:.metadata.ownerReferences[0].kind
kubectl get all -l app=<name>      # All resources with specific label
kubectl get events --field-selector involvedObject.name=<resource-name>     # Events for specific resource

### Advanced Debugging and Troubleshooting

When applications misbehave, these debugging commands help you identify and resolve issues quickly. Understanding these techniques is crucial for maintaining production systems.

# Pod debugging and log analysis
kubectl logs <pod-name> --since=1h                      # Logs from last hour
kubectl logs <pod-name> --since-time=2023-01-01T00:00:00Z # Logs since specific time
kubectl logs -f <pod-name> --tail=100                   # Follow last 100 log lines
kubectl logs <pod-name> --previous --tail=50      # Previous container logs (after restart)
kubectl logs -l app=<name> --prefix=true          # Logs from multiple pods with pod prefix

# Network debugging with temporary pods
kubectl run debug-pod --image=nicolaka/netshoot --rm -it -- /bin/bash  # Network debugging pod
kubectl run dns-debug --image=busybox --rm -it -- nslookup kubernetes.default # DNS debugging
kubectl run curl-debug --image=curlimages/curl --rm -it -- sh     # HTTP debugging pod

# Resource and capacity analysis
kubectl describe nodes | grep -A 5 "Allocated resources"       # Node resource allocation
kubectl top nodes --sort-by=memory                             # Node resource usage
kubectl get pods --all-namespaces -o wide | grep <node-name>   # Pods on specific node
kubectl describe node <node-name> | grep -A 10 "Non-terminated Pods" #Pods consuming node resources

# Event analysis and correlation
kubectl get events --sort-by='.lastTimestamp' | tail -20               # Recent events
kubectl get events --field-selector type=Warning                       # Warning events only
kubectl get events --field-selector reason=FailedScheduling            # Scheduling failures
kubectl get events --field-selector involvedObject.kind=Pod            # Pod-related events
kubectl get events --watch                                    # Watch events in real-time

# Port forwarding for local debugging  
kubectl port-forward pod/<pod-name> 8080:80                # Forward pod port to local
kubectl port-forward deployment/<name> 8080:80             # Forward deployment port
kubectl port-forward service/<service-name> 8080:80        # Forward service port

# Resource patching and modification
kubectl patch pod <pod-name> --patch '{"metadata":{"labels":{"env":"debug"}}}' # Add label to pod
kubectl patch deployment <name> --type='strategic' --patch ='{"spec":{"template":{"metadata":{"labels":{"version":"v2"}}}}}' # Strategic patch
kubectl patch deployment <name> --type='json' --patch='[{"op": "replace", "path": "/spec/replicas", "value": 3}]' # JSON patch

### Batch Operations and Automation
Efficient Kubernetes management often requires operating on multiple resources simultaneously. These commands enable powerful batch operations and automation workflows.

# Batch resource deletion and cleanup
kubectl delete pods --all                                   # Delete all pods in namespace
kubectl delete deployment,service,configmap -l app=<name>   # Delete multiple resource types by label
kubectl get pods --output name | grep <pattern> | xargs kubectl delete  # Delete pods matching pattern
kubectl get pods --field-selector=status.phase=Failed --output name | xargs kubectl delete # Delete failed pods

# Batch information gathering
kubectl get pods --output jsonpath='{range .items[*]}{.metadata.name}{" "}{.status.phase}{"\n"}{end}' # Pod names and phases
kubectl get deployments --output jsonpath='{range .items[*]}{.metadata.name}{" "}{.spec.replicas}{"/"}{.status.readyReplicas}{"\n"}{end}' # Deployment status
kubectl get nodes --output jsonpath='{range .items[*]}{.metadata.name}{" "}{.status.conditions[?(@.type=="Ready")].status}{"\n"}{end}' # Node readiness

# Resource export and backup operations
kubectl get deployment <name> --output yaml --export > deployment-backup.yaml # Export deployment (deprecated in newer versions)
kubectl get deployment <name> --output yaml > deployment-backup.yaml         # Export deployment configuration
kubectl get all -l app=<name> --output yaml > app-backup.yaml               # Export all resources for an app
kubectl create secret generic backup-secret --from-file=./backup/      # Create secret from backup files

# Automation-friendly operations
kubectl wait --for=condition=ready pod -l app=<name> --timeout=300s     # Wait for pods to be ready
kubectl wait --for=condition=available deployment/<name> --timeout=300s # Wait for deployment to be available
kubectl get pods -l app=<name> --no-headers -o custom-columns=":metadata.name" # Pod names only (no headers)

### Security and Access Control

Understanding security contexts and permissions is vital for production Kubernetes environments. These commands help you verify and manage security configurations.

# Permission and authentication verification
kubectl auth can-i create deployments    # Check if you can create deployments
kubectl auth can-i delete pods --all-namespaces   # Check cluster-wide pod deletion rights
kubectl auth can-i get secrets --namespace kube-system # Check access to secrets in specific namespace
kubectl auth can-i create pods --as=system:serviceaccount:default:default # Check permissions as service account

# Service account management
kubectl get serviceaccounts        # List service accounts
kubectl describe serviceaccount default  # Service account details
kubectl create serviceaccount <sa-name>    # Create service account
kubectl get secret $(kubectl get serviceaccount default --output jsonpath='{.secrets[0].name}') --output yaml # Service account token

# Security context and RBAC inspection
kubectl describe pod <pod-name> | grep -A 10 "Security Context"  # Pod security context
kubectl get rolebindings,clusterrolebindings --all-namespaces    # List role bindings
kubectl describe clusterrole cluster-admin                    # Cluster role permissions
kubectl whoami 2>/dev/null || kubectl auth whoami             # Current user identity

### Resource Management and Optimization
Proper resource management ensures optimal cluster performance and cost efficiency. These commands help you monitor and optimize resource utilization across your cluster.

# Resource quota and limit management
kubectl describe resourcequota       # View resource quotas
kubectl describe limitrange           # View limit ranges
kubectl top nodes                      # Node resource usage
kubectl top pods --all-namespaces --sort-by=memory    # Top memory consuming pods
kubectl top pods --all-namespaces --sort-by=cpu         # Top CPU consuming pods

# Capacity planning and analysis
kubectl describe nodes | grep -A 5 Capacity    # Node capacity information
kubectl get pods --all-namespaces --output jsonpath='{range .items[*]}{.spec.nodeName}{"\t"}{.metadata.name}{"\n"}{end}' | sort | uniq -c # Pod distribution per node
kubectl get pods --output jsonpath='{range .items[*]}{.metadata.name}{": requests="}{.spec.containers[0].resources.requests}{", limits="}{.spec.containers[0].resources.limits}{"\n"}{end}' # Pod resource requests/limits

# Performance monitoring and metrics
kubectl get --raw /metrics    # Raw metrics from API server (if enabled)
kubectl get --raw /api/v1/nodes/<node-name>/proxy/metrics/cadvisor     # Node metrics via proxy
kubectl proxy --port=8080 &    # Start kubectl proxy for metrics access

### Cluster Administration and Maintenance
These administrative commands help you maintain cluster health and perform routine maintenance tasks that keep your Kubernetes environment running smoothly.
# Cluster information and health checks
kubectl cluster-info           # Basic cluster information
kubectl cluster-info dump       # Detailed cluster state dump
kubectl get componentstatuses                       # Control plane component health
kubectl version                          # Client and server version information
kubectl api-resources                   # Available API resources
kubectl api-versions                       # Available API versions

# Node management and maintenance
kubectl get nodes                         # List cluster nodes
kubectl describe node <node-name>          # Detailed node information
kubectl cordon <node-name>                  # Mark node as unschedulable
kubectl uncordon <node-name>                 # Mark node as schedulable
kubectl drain <node-name> --ignore-daemonsets --delete-emptydir-data  # Safely drain node for maintenance

# Namespace management
kubectl get namespaces               # List all namespaces
kubectl create namespace <namespace-name>       # Create namespace
kubectl delete namespace <namespace-name>         # Delete namespace
kubectl config set-context --current --namespace=<namespace>  # Switch default namespace

# System troubleshooting
kubectl get events --all-namespaces --sort-by='.lastTimestamp'   # Cluster-wide recent events
kubectl logs -n kube-system <system-pod-name>    # System component logs
kubectl get pods -n kube-system                # System pods status

### Quick Reference Command Patterns
Understanding these command patterns will help you construct the right kubectl command for any situation you encounter in your Kubernetes journey.
# General command structure patterns
kubectl <action> <resource-type> <resource-name> [flags]    # Basic command structure
kubectl <action> <resource-type> -l <label-selector> [flags]  # Action on labeled resources
kubectl <action> <resource-type> --field-selector=<field>=<value> #Action with field selection
kubectl <action> <resource-type> -o <output-format>    # Custom output format

# Common flag combinations for efficiency
kubectl get <resource> --output wide --sort-by=<jsonpath>       # Wide output with sorting
kubectl get <resource> -w --output-watch-events               # Watch with event details
kubectl get <resource> --all-namespaces -l <selector>         # Cross-namespace with labels
kubectl describe <resource> <name> | grep -A <N> <pattern>    # Filtered describe output

# Useful aliases for common operations (add to your shell profile)
alias kgpa='kubectl get pods --all-namespaces'    # Get all pods cluster-wide
alias kgpw='kubectl get pods -o wide'              # Get pods with wide output
alias kgdw='kubectl get deployments -o wide'        # Get deployments with wide output
alias kdrain='kubectl drain --ignore-daemonsets --delete-emptydir-data' # Safe node drain
alias kuncordon='kubectl uncordon'             # Uncordon node
alias kwait='kubectl wait --for=condition=ready'      # Wait for ready condition