# ============================================================================
# 01-namespace.yaml
# ============================================================================
apiVersion: v1
kind: Namespace
metadata:
  name: web-volume-demo
  labels:
    name: web-volume-demo
    environment: development
    team: devops
  annotations:
    description: "Namespace for web server volume demonstration"
spec:
  finalizers: ["kubernetes"]
---
# ============================================================================
# 02-storage-class.yaml
# ============================================================================
# StorageClass acts like a "blueprint" or "template" that defines different types of storage
# Think of it like choosing between different tiers of cloud storage (basic, premium, ultra-fast)

apiVersion: storage.k8s.io/v1  # Uses the stable storage API - this has been around since Kubernetes 1.6
kind: StorageClass            # Tells Kubernetes this is a StorageClass resource, not a Pod or Service

metadata:
  name: fast-ssd              # The name applications will reference when requesting this storage type
                             # Choose descriptive names that indicate performance characteristics
  annotations:
    # This annotation controls whether this StorageClass is automatically chosen
    # when no specific StorageClass is requested in a PersistentVolumeClaim
    storageclass.kubernetes.io/is-default-class: "false"  # "false" means this won't be used automatically
                                                          # Set to "true" if you want this as your cluster default

# The provisioner is like telling Kubernetes "which storage system should handle this"
provisioner: kubernetes.io/aws-ebs  # This built-in provisioner creates AWS EBS volumes
                                    # Change to kubernetes.io/gce-pd for Google Cloud
                                    # or kubernetes.io/azure-disk for Azure
                                    # Each cloud provider has different provisioners

parameters:  # These are the specific settings passed to the storage provisioner
             # Think of these as the "recipe" for creating the storage volume
  
  type: gp3                    # AWS EBS volume type - gp3 is the latest general purpose SSD
                              # gp3 offers better price/performance than older gp2 volumes
                              # Other options: gp2, io1, io2, st1, sc1
  
  iops: "3000"                # Input/Output Operations Per Second - how many read/write operations
                              # 3000 IOPS provides good performance for most database workloads
                              # gp3 allows you to provision IOPS independently of size (unlike gp2)
  
  throughput: "125"           # Megabytes per second of sustained data transfer
                              # 125 MB/s is the baseline for gp3 volumes
                              # Higher throughput helps with large file operations and backups
  
  fsType: ext4                # The filesystem format applied to the volume when first created
                              # ext4 is reliable and widely supported on Linux
                              # Other options: xfs, ext3 (xfs often better for large files)
  
  encrypted: "true"           # Enables encryption at rest using AWS-managed keys
                              # Critical for compliance and security in production
                              # Minimal performance impact with modern hardware

# What happens to the storage when the PersistentVolume is no longer needed
reclaimPolicy: Delete         # "Delete" removes the underlying storage completely
                             # "Retain" keeps the storage (you pay for it but data persists)
                             # "Recycle" is deprecated - don't use this option

# Controls whether volumes can be resized after creation
allowVolumeExpansion: true   # "true" allows growing volumes without downtime
                            # Very useful for databases that outgrow initial storage
                            # Cannot shrink volumes - only expand

# Controls when and where the volume gets created
volumeBindingMode: WaitForFirstConsumer  # Creates volume only when a Pod actually needs it
                                        # Ensures volume is created in same availability zone as the Pod
                                        # Prevents cross-AZ data transfer charges
                                        # Alternative: "Immediate" creates volume right away

# Additional mount options passed to the filesystem driver
mountOptions: []            # Empty array means no special mount options
                           # Could include options like: ["noatime", "nodiratime"] for performance
                           # Or ["ro"] for read-only mounts
                           # These are filesystem-specific options---
# ============================================================================
# 03-persistent-volume.yaml
# ============================================================================
# A PersistentVolume (PV) is like reserving a specific piece of storage in your cluster
# Think of it as claiming a particular storage device and making it available for Pods to use
# This is different from StorageClass, which is just a template - PV is the actual storage

apiVersion: v1              # Uses core Kubernetes API - PVs have been stable since early versions
kind: PersistentVolume      # This creates an actual storage resource, not just a template

metadata:
  name: web-content-pv      # Unique name for this specific piece of storage
                           # Once created, this PV exists until manually deleted
  labels:
    app: web-server         # Labels help organize and select PVs
    type: web-content       # Descriptive label indicating what this storage contains

spec:
  capacity:
    storage: 5Gi           # Total size of this storage volume
                          # 5 Gibibytes (5 * 1024^3 bytes) - binary measurement
                         # This is the maximum space available to any Pod using this PV
  volumeMode: Filesystem 
  accessModes:             # How many Pods can use this storage and how
    - ReadWriteOnce        # RWO: Only ONE Pod can mount this volume at a time with read-write access
                          # Other options: ReadOnlyMany (multiple Pods, read-only)
                          #                ReadWriteMany (multiple Pods, read-write - rare support)
                          # Most storage systems only support ReadWriteOnce

  persistentVolumeReclaimPolicy: Retain  # What happens when the PV is no longer claimed
                                        # "Retain" keeps the data even after PVC is deleted
                                        # "Delete" removes the underlying storage completely
                                        # "Recycle" is deprecated (don't use)

  storageClassName: fast-ssd            # Links this PV to the StorageClass we defined earlier
                                       # This creates a relationship between storage template and actual storage
                                       # Pods requesting "fast-ssd" storage could get this PV

# IMPORTANT CONCEPTUAL ISSUE: You can only specify ONE storage backend type
# Your current config tries to use three different storage types simultaneously
# Let me show you the correct way to configure each option:

# OPTION 1: Using hostPath (local node storage - for development/testing only)
  hostPath:
    path: /tmp/web-content          # Directory on the Kubernetes node's filesystem
    type: DirectoryOrCreate         # Creates the directory if it doesn't exist
                                   # WARNING: Data tied to specific node - not portable
                                   # If Pod moves to different node, it loses access to data

# OPTION 2: Using NFS (Network File System - good for shared storage)
# UNCOMMENT THIS SECTION AND COMMENT OUT hostPath TO USE NFS:
  nfs: 
    server: 192.168.1.100         # IP address of your NFS server
    path: /exports/web-content     # Path on the NFS server to the shared directory
#                                  # NFS allows ReadWriteMany access mode
#                                  # Multiple Pods can access the same data simultaneously

# OPTION 3: Using AWS EBS (Elastic Block Store - for production AWS environments)
# UNCOMMENT THIS SECTION AND COMMENT OUT hostPath TO USE AWS EBS:
#  awsElasticBlockStore: 
#    volumeID: vol-0123456789abcdef0  # Existing EBS volume ID from AWS console
#    fsType: ext4                     # Filesystem type (should match StorageClass)
#                                    # EBS volumes are tied to specific availability zones
#                                    # Only supports ReadWriteOnce access mode

# TEACHING MOMENT: Understanding Storage Backend Types
# 
# hostPath: Uses local disk on the node - fast but not portable between nodes
#           Good for: Development, testing, node-specific data like logs
#           Bad for: Production apps that need to move between nodes
#
# NFS: Network-attached storage accessible from any node
#      Good for: Shared data, content that multiple Pods need to access
#      Bad for: High-performance databases (network latency)
#
# Cloud Block Storage (EBS/GCE-PD/Azure Disk): Managed by cloud provider
#                                              Good for: Production databases, reliable storage
#                                              Bad for: Multi-Pod access (usually ReadWriteOnce only)
#
# The key insight: Choose your storage backend based on your access patterns and requirements!---
# ============================================================================
# 04-persistent-volume-claim.yaml  
# ============================================================================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: web-content-pvc
  namespace: web-volume-demo
  labels:
    app: web-server
    component: storage
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: fast-ssd
  resources:
    requests:
      storage: 5Gi
  selector:
    matchLabels:
      app: web-server
      type: web-content

---
# ============================================================================
# 05-configmap.yaml
# ============================================================================
apiVersion: v1
kind: ConfigMap
metadata:
  name: web-config
  namespace: web-volume-demo
  labels:
    app: web-server
    component: configuration
data:
  # Environment variables
  server_name: "demo.example.com"
  max_connections: "1000"
  log_level: "info"
  worker_processes: "auto"
  worker_connections: "1024"
  
  # Nginx configuration file
  nginx.conf: |
    server {
        listen 80;
        server_name demo.example.com;
        root /usr/share/nginx/html;
        index index.html index.htm;
        
        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header Referrer-Policy "no-referrer-when-downgrade" always;
        add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
        
        # Gzip compression
        gzip on;
        gzip_vary on;
        gzip_min_length 1024;
        gzip_types text/plain text/css text/xml text/javascript application/javascript application/xml+rss application/json;
        
        # Custom log format
        log_format custom '$remote_addr - $remote_user [$time_local] '
                         '"$request" $status $body_bytes_sent '
                         '"$http_referer" "$http_user_agent" '
                         '$request_time $upstream_response_time';
        
        access_log /var/log/nginx/access.log custom;
        error_log /var/log/nginx/error.log warn;
        
        # Health check endpoint
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
        
        # Readiness check endpoint  
        location /ready {
            access_log off;
            return 200 "ready\n";
            add_header Content-Type text/plain;
        }
        
        # Metrics endpoint for monitoring
        location /nginx-status {
            stub_status on;
            access_log off;
            allow 127.0.0.1;
            allow 10.0.0.0/8;
            allow 172.16.0.0/12;
            allow 192.168.0.0/16;
            deny all;
        }
        
        # Main application
        location / {
            try_files $uri $uri/ =404;
            expires 1h;
            add_header Cache-Control "public, immutable";
        }
        
        # Static assets with long cache
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
            add_header Vary "Accept-Encoding";
        }
        
        # API endpoints (if any)
        location /api/ {
            proxy_pass http://backend-service:8080/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }
    }

  # Custom HTML content
  index.html: |
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Kubernetes Volume Demo</title>
        <style>
            body {
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                line-height: 1.6;
                margin: 0;
                padding: 20px;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                min-height: 100vh;
            }
            .container {
                max-width: 800px;
                margin: 0 auto;
                background: rgba(255, 255, 255, 0.1);
                padding: 30px;
                border-radius: 15px;
                backdrop-filter: blur(10px);
                box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
                border: 1px solid rgba(255, 255, 255, 0.18);
            }
            h1 {
                text-align: center;
                margin-bottom: 30px;
                font-size: 2.5em;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            }
            .info-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
                gap: 20px;
                margin: 30px 0;
            }
            .info-card {
                background: rgba(255, 255, 255, 0.1);
                padding: 20px;
                border-radius: 10px;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }
            .info-card h3 {
                margin-top: 0;
                color: #ffd700;
            }
            .volume-list {
                list-style: none;
                padding: 0;
            }
            .volume-list li {
                background: rgba(255, 255, 255, 0.1);
                margin: 10px 0;
                padding: 15px;
                border-radius: 5px;
                border-left: 4px solid #ffd700;
            }
            .status {
                display: inline-block;
                padding: 5px 15px;
                border-radius: 20px;
                background: #28a745;
                color: white;
                font-weight: bold;
            }
            .links {
                text-align: center;
                margin-top: 30px;
            }
            .links a {
                display: inline-block;
                margin: 10px;
                padding: 10px 20px;
                background: rgba(255, 255, 255, 0.2);
                color: white;
                text-decoration: none;
                border-radius: 25px;
                border: 1px solid rgba(255, 255, 255, 0.3);
                transition: all 0.3s ease;
            }
            .links a:hover {
                background: rgba(255, 255, 255, 0.3);
                transform: translateY(-2px);
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>🚀 Kubernetes Volume Demo</h1>
            <div class="info-grid">
                <div class="info-card">
                    <h3>📊 System Status</h3>
                    <p><span class="status">RUNNING</span></p>
                    <p><strong>Pod Name:</strong> <span id="pod-name">Loading...</span></p>
                    <p><strong>Namespace:</strong> web-volume-demo</p>
                    <p><strong>Started:</strong> <span id="timestamp"></span></p>
                </div>
                <div class="info-card">
                    <h3>💾 Volume Types</h3>
                    <ul class="volume-list">
                        <li><strong>ConfigMap:</strong> /etc/nginx/conf.d</li>
                        <li><strong>PVC:</strong> /usr/share/nginx/html</li>
                        <li><strong>EmptyDir:</strong> /tmp (Memory)</li>
                        <li><strong>Secret:</strong> Environment Variables</li>
                    </ul>
                </div>
            </div>
            <div class="links">
                <a href="/health">Health Check</a>
                <a href="/ready">Ready Check</a>
                <a href="/nginx-status">Nginx Status</a>
            </div>
        </div>
        
        <script>
            // Set timestamp
            document.getElementById('timestamp').textContent = new Date().toLocaleString();
            
            // Try to get pod name from meta endpoint (if available)
            fetch('/api/pod-info').then(r => r.json()).then(data => {
                document.getElementById('pod-name').textContent = data.podName || 'demo-pod';
            }).catch(() => {
                document.getElementById('pod-name').textContent = 'demo-pod-' + Math.random().toString(36).substr(2, 5);
            });
        </script>
    </body>
    </html>

---
# ============================================================================
# 06-secret.yaml
# ============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: web-secret
  namespace: web-volume-demo
  labels:
    app: web-server
    component: credentials
type: Opaque
data:
  # Base64 encoded values
  username: YWRtaW4=  # admin
  password: cGFzc3dvcmQxMjM=  # password123
  api_key: YWJjZGVmZ2hpams=  # abcdefghijk
  database_url: cG9zdGdyZXNxbDovL3VzZXI6cGFzc0Bsb2NhbGhvc3Q6NTQzMi9kYg==  # postgresql://user:pass@localhost:5432/db
stringData:
  # Plain text values (will be automatically base64 encoded)
  jwt_secret: "super-secret-jwt-key-change-in-production"
  encryption_key: "32-char-encryption-key-change-me"

---
# ============================================================================
# 07-service-account.yaml
# ============================================================================
# RBAC (Role-Based Access Control) in Kubernetes follows the principle of least privilege
# Think of it like employee access cards - you only get access to areas you need for your job

# ============================================================================
# WHAT IS A SERVICE ACCOUNT?
# ============================================================================
# A ServiceAccount is like an "identity card" for Pods running in Kubernetes
# - Every Pod runs under a ServiceAccount (default: "default" ServiceAccount)
# - ServiceAccounts can be assigned specific permissions via RBAC
# - They're namespace-scoped (each namespace has its own ServiceAccounts)

apiVersion: v1
kind: ServiceAccount
metadata:
  name: web-server-sa
  namespace: web-volume-demo
  labels:
    app: web-server
    component: rbac                    # RBAC = Role-Based Access Control
                                      # This component manages security and permissions
  annotations:
    # Optional: Add description for documentation
    description: "Service account for web server pods with minimal required permissions"
    
# Controls whether Kubernetes automatically mounts the ServiceAccount token into Pods
automountServiceAccountToken: false    # "true" = automatically inject API credentials
                                     # "false" = don't mount token (more secure if API access not needed)
                                     # The token allows Pods to communicate with Kubernetes API

# Optional: You can attach secrets to ServiceAccounts
# secrets:
# - name: web-server-secret           # Custom secret containing additional credentials
#   namespace: web-volume-demo

---
# ============================================================================
# WHAT IS A ROLE?
# ============================================================================
# A Role defines WHAT actions are allowed on WHICH resources
# Think of it like a job description - "Sales Manager can read customer data and create orders"
# 
# KEY CONCEPTS:
# - apiGroups: Which API group the resource belongs to ("" = core API group)
# - resources: What Kubernetes objects (pods, services, configmaps, etc.)
# - verbs: What actions (get, list, create, update, delete, etc.)

apiVersion: rbac.authorization.k8s.io/v1
kind: Role                            # Role = namespace-scoped permissions
                                     # ClusterRole = cluster-wide permissions
metadata:
  namespace: web-volume-demo          # This Role only applies within this namespace
  name: web-server-role
  labels:
    app: web-server
    component: rbac
  annotations:
    description: "Minimal permissions for web server operation and debugging"

rules:
# Rule 1: Configuration Access
# WHY: Web servers often need to read their configuration at runtime
- apiGroups: [""]                    # "" = core API group (pods, services, configmaps, etc.)
  resources: ["configmaps", "secrets"]
  verbs: ["get", "list", "watch"]    # get = read single item
                                     # list = read multiple items  
                                     # watch = get notified of changes
  # Optional: Restrict to specific resources
  # resourceNames: ["web-config", "web-secrets"]  # Only these specific resources

# Rule 2: Event Creation for Debugging
# WHY: Applications can create Events to log important information for operators
- apiGroups: [""]
  resources: ["events"] 
  verbs: ["create"]                  # Only allow creating events, not reading/deleting them

# Rule 3: Pod Self-Discovery
# WHY: Applications sometimes need to know about their own Pod or sibling Pods
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["get", "list"]             # Read-only access to pod information
  # Note: No "watch" verb - we don't need real-time pod updates

# Rule 4: Service Discovery (OPTIONAL - uncomment if needed)
# WHY: Applications might need to discover other services dynamically
# - apiGroups: [""]
#   resources: ["services", "endpoints"]
#   verbs: ["get", "list"]

# Rule 5: Metrics Access (OPTIONAL - uncomment if using custom metrics)
# WHY: For applications that expose custom metrics to monitoring systems
# - apiGroups: ["metrics.k8s.io"]
#   resources: ["pods", "nodes"]
#   verbs: ["get", "list"]

---
# ============================================================================
# WHAT IS A ROLEBINDING?
# ============================================================================
# A RoleBinding connects a ServiceAccount (WHO) to a Role (WHAT they can do)
# Think of it like: "Give Alice (ServiceAccount) the Sales Manager role (Role)"

apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding                    # RoleBinding = namespace-scoped binding
                                     # ClusterRoleBinding = cluster-wide binding
metadata:
  name: web-server-binding
  namespace: web-volume-demo
  labels:
    app: web-server
    component: rbac
  annotations:
    description: "Binds web-server ServiceAccount to web-server Role"

# WHO gets the permissions (can be ServiceAccounts, Users, or Groups)
subjects:
- kind: ServiceAccount               # Type of principal getting permissions
  name: web-server-sa               # Name of the ServiceAccount
  namespace: web-volume-demo        # Namespace of the ServiceAccount

# WHAT permissions they get
roleRef:                            # Reference to the Role to bind
  kind: Role                        # Could be "Role" or "ClusterRole"
  name: web-server-role            # Name of the Role defined above
  apiGroup: rbac.authorization.k8s.io  # API group for RBAC resources

---
# ============================================================================
# 08-deployment.yaml (Enhanced version of your original)
# ============================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-server-deployment
  namespace: web-volume-demo
  labels:
    app: web-server
    version: v1.0
    environment: development
  annotations:
    description: "Web server deployment with comprehensive volume examples"
    maintainer: "devops-team@company.com"
    deployment.kubernetes.io/revision: "1"
spec:
  replicas: 2
  revisionHistoryLimit: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app: web-server
      version: v1.0
  template:
    metadata:
      labels:
        app: web-server
        version: v1.0
        environment: development
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "80"
        prometheus.io/path: "/nginx-status"
    spec:
      serviceAccountName: web-server-sa
      automountServiceAccountToken: true
      # Security Context
      securityContext:
        runAsUser: 101  # nginx user
        runAsGroup: 101 # nginx group
        runAsNonRoot: true
        fsGroup: 101
        fsGroupChangePolicy: "OnRootMismatch"
      
      # Init Container to setup content
      initContainers:
      - name: content-setup
        image: busybox:1.36
        command: ['sh', '-c']
        args:
        - |
          echo "Setting up web content..."
          cp /config/index.html /web-content/
          echo "<h2>Content initialized at $(date)</h2>" >> /web-content/index.html
          echo "<p>This content is stored on persistent volume</p>" >> /web-content/index.html
          echo "Setup complete!"
        volumeMounts:
        - name: web-content
          mountPath: /web-content
        - name: nginx-config
          mountPath: /config
        securityContext:
          runAsUser: 101
          runAsGroup: 101
          runAsNonRoot: true
          allowPrivilegeEscalation: false
      
      containers:
      - name: web-server
        image: nginx:1.25-alpine
        imagePullPolicy: IfNotPresent
        
        ports:
        - name: http
          containerPort: 80
          protocol: TCP
        - name: https  
          containerPort: 443
          protocol: TCP
        
        # Environment variables from ConfigMap and Secret
        env:
        - name: SERVER_NAME
          valueFrom:
            configMapKeyRef:
              name: web-config
              key: server_name
        - name: MAX_CONNECTIONS
          valueFrom:
            configMapKeyRef:
              name: web-config
              key: max_connections
        - name: USERNAME
          valueFrom:
            secretKeyRef:
              name: web-secret
              key: username
        - name: PASSWORD
          valueFrom:
            secretKeyRef:
              name: web-secret
              key: password
        - name: LOG_LEVEL
          value: "info"
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: POD_IP
          valueFrom:
            fieldRef:
              fieldPath: status.podIP
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        
        # Import all keys from ConfigMap as environment variables
        envFrom:
        - configMapRef:
            name: web-config
        - secretRef:
            name: web-secret
        
        # Volume mounts inside the container
        volumeMounts:
        # ConfigMap volume - nginx configuration
        - name: nginx-config
          mountPath: /etc/nginx/conf.d
          readOnly: true
        # Persistent Volume - web content
        - name: web-content
          mountPath: /usr/share/nginx/html
        # EmptyDir (Memory) - temporary storage
        - name: temp-storage
          mountPath: /tmp
        # HostPath volume - logs
        - name: logs
          mountPath: /var/log/nginx
        # Additional volumes for nginx
        - name: nginx-cache
          mountPath: /var/cache/nginx
        - name: nginx-run
          mountPath: /var/run
        
        # Resource limits
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
            ephemeral-storage: "1Gi"
          limits:
            memory: "512Mi"
            cpu: "500m"
            ephemeral-storage: "2Gi"
        
        # Security Context
        securityContext:
          runAsUser: 101
          runAsGroup: 101
          runAsNonRoot: true
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: false  # nginx needs to write to some locations
          capabilities:
            drop:
            - ALL
            add:
            - NET_BIND_SERVICE
        
        # Health Checks
        startupProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 10
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 6
          successThreshold: 1
        
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
          successThreshold: 1
        
        readinessProbe:
          httpGet:
            path: /ready
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
          successThreshold: 1
        
        # Lifecycle hooks
        lifecycle:
          preStop:
            exec:
              command: ["/bin/sh", "-c", "sleep 10"]
      
      # Volume definitions
      volumes:
      # ConfigMap volume
      - name: nginx-config
        configMap:
          name: web-config
          items:
          - key: nginx.conf
            path: default.conf
          - key: index.html
            path: index.html
          defaultMode: 0644
      
      # Persistent Volume Claim
      - name: web-content
        persistentVolumeClaim:
          claimName: web-content-pvc
      
      # Temporary storage (memory-backed)
      - name: temp-storage
        emptyDir:
          medium: Memory
          sizeLimit: 128Mi
      
      # Host path volume for logs
      - name: logs
        hostPath:
          path: /var/log/containers/web-server
          type: DirectoryOrCreate
      
      # Additional EmptyDir volumes for nginx
      - name: nginx-cache
        emptyDir:
          sizeLimit: 100Mi
      
      - name: nginx-run
        emptyDir:
          sizeLimit: 50Mi
      
      # DNS Configuration
      dnsPolicy: ClusterFirst
      
      # Termination Grace Period
      terminationGracePeriodSeconds: 30
      
      # Node Selection (optional)
      # nodeSelector:
      #   disktype: ssd

---
# ============================================================================
# 09-service.yaml
# ============================================================================
apiVersion: v1
kind: Service
metadata:
  name: web-server-service
  namespace: web-volume-demo
  labels:
    app: web-server
    component: service
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"  # For AWS
    prometheus.io/scrape: "true"
    prometheus.io/port: "80"
    prometheus.io/path: "/nginx-status"
spec:
  type: ClusterIP
  selector:
    app: web-server
    version: v1.0
  ports:
  - name: http
    port: 80
    targetPort: http
    protocol: TCP
  - name: https
    port: 443
    targetPort: https
    protocol: TCP
  sessionAffinity: ClientIP
  sessionAffinityConfig:
    clientIP:
      timeoutSeconds: 10800  # 3 hours

---
# ============================================================================
# 10-ingress.yaml
# ============================================================================
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: secure-multi-path-ingress
  namespace: web-volume-demo
  labels:
    app: web-server
    component: ingress
    environment: production
  annotations:
    # SSL Certificate Management
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    
    # SECURITY: Force HTTPS
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    
    # Multi-path routing configuration
    nginx.ingress.kubernetes.io/rewrite-target: /$2
    nginx.ingress.kubernetes.io/use-regex: "true"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTP"
    
    # Performance settings
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
    
    # SECURITY: Comprehensive security headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      more_set_headers "X-Frame-Options: DENY";
      more_set_headers "X-Content-Type-Options: nosniff";
      more_set_headers "X-XSS-Protection: 1; mode=block";
      more_set_headers "Strict-Transport-Security: max-age=31536000; includeSubDomains; preload";
      more_set_headers "Referrer-Policy: strict-origin-when-cross-origin";
      more_set_headers "Permissions-Policy: camera=(), microphone=(), geolocation=()";
      more_set_headers "Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'";
    
    # SECURITY: Rate limiting
    nginx.ingress.kubernetes.io/rate-limit-connections: "25"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    nginx.ingress.kubernetes.io/rate-limit-rpm: "150"

spec:
  ingressClassName: nginx
  
  rules:
  - host: your-domain.com  # Replace with your actual domain
    http:
      paths:
      # Main web application
      - path: /()(.*)
        pathType: ImplementationSpecific
        backend:
          service:
            name: web-server-service
            port:
              number: 80
      
      # API backend service
      - path: /api/(.*)
        pathType: ImplementationSpecific
        backend:
          service:
            name: api-service
            port:
              number: 8080
      
      # Static assets service
      - path: /static/(.*)
        pathType: ImplementationSpecific
        backend:
          service:
            name: static-assets-service
            port:
              number: 80

  # SECURITY: TLS encryption
  tls:
  - hosts:
    - your-domain.com
    secretName: web-server-tls

---
# ============================================================================
# 11-hpa.yaml - Horizontal Pod Autoscaler
# ============================================================================

# Specify the API version for HPA - v2 is the current stable version
apiVersion: autoscaling/v2
# Define this as a HorizontalPodAutoscaler resource
kind: HorizontalPodAutoscaler

# Metadata section contains identifying information about this HPA
metadata:
  # Name of this HPA resource - used to reference it in kubectl commands
  name: web-server-hpa
  
  # Namespace where this HPA will be created - must match the target deployment's namespace
  namespace: web-volume-demo
  
  # Labels help organize and select resources - these are optional but recommended
  labels:
    app: web-server          # Indicates this belongs to the web-server application
    component: autoscaling   # Identifies this as an autoscaling component

# Specification section defines how the HPA should behave
spec:
  # Target reference - tells HPA which deployment to scale
  scaleTargetRef:
    apiVersion: apps/v1              # API version of the target resource
    kind: Deployment                 # Type of resource to scale (Deployment in this case)
    name: web-server-deployment      # Name of the specific deployment to scale

  # Minimum number of pod replicas - HPA will never scale below this number
  minReplicas: 2
  
  # Maximum number of pod replicas - HPA will never scale above this number
  maxReplicas: 10

  # Metrics section defines what triggers scaling decisions
  metrics:
  # First metric: CPU utilization
  - type: Resource                   # This is a resource-based metric (CPU, memory, etc.)
    resource:
      name: cpu                      # Monitor CPU usage
      target:
        type: Utilization            # Use percentage utilization (not absolute values)
        averageUtilization: 70       # Scale up when average CPU across all pods exceeds 70%

  # Second metric: Memory utilization  
  - type: Resource                   # Another resource-based metric
    resource:
      name: memory                   # Monitor memory usage
      target:
        type: Utilization            # Use percentage utilization
        averageUtilization: 80       # Scale up when average memory across all pods exceeds 80%

  # Behavior section controls HOW scaling happens (timing and rates)
  behavior:
    # Scale-up behavior - when adding more pods
    scaleUp:
      # Wait 60 seconds after scaling before making another scale-up decision
      stabilizationWindowSeconds: 60
      
      # Scaling policies define the rate limits for scaling up
      policies:
      - type: Percent                # Scale by percentage (not absolute number)
        value: 100                   # Can double the number of pods (100% increase)
        periodSeconds: 15            # Every 15 seconds, evaluate for scale-up

    # Scale-down behavior - when removing pods
    scaleDown:
      # Wait 300 seconds (5 minutes) after scaling before making another scale-down decision
      # This prevents rapid scaling down which could cause instability
      stabilizationWindowSeconds: 300
      
      # Scaling policies for scaling down
      policies:
      - type: Percent                # Scale by percentage
        value: 10                    # Can only reduce by 10% of current pods
        periodSeconds: 60            # Every 60 seconds, evaluate for scale-down

# ============================================================================
# 12-pdb.yaml - Pod Disruption Budget
# ============================================================================
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: web-server-pdb
  namespace: web-volume-demo
  labels:
    app: web-server
    component: availability
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: web-server
      version: v1.0

---
# ============================================================================
# 13-network-policy.yaml - Network Policy for security
# ============================================================================
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: web-server-network-policy
  namespace: web-volume-demo
  labels:
    app: web-server
    component: security
spec:
  podSelector:
    matchLabels:
      app: web-server
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Allow ingress from ingress controller
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    - podSelector:
        matchLabels:
          app.kubernetes.io/name: ingress-nginx
    ports:
    - protocol: TCP
      port: 80
    - protocol: TCP
      port: 443
  # Allow ingress from monitoring namespace
  - from:
    - namespaceSelector:
        matchLabels:
          name: monitoring
    ports:
    - protocol: TCP
      port: 80
  egress:
  # Allow DNS resolution
  - to:
    - namespaceSelector:
        matchLabels:
          kubernetes.io/metadata.name: kube-system
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
  # Allow communication within same namespace
  - to:
    - podSelector: {}
    ports:
    - protocol: TCP
      port: 80

---
# ============================================================================
# 14-servicemonitor.yaml - Prometheus ServiceMonitor (if using Prometheus Operator)
# ============================================================================
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: web-server-metrics
  namespace: web-volume-demo
  labels:
    app: web-server
    component: monitoring
spec:
  selector:
    matchLabels:
      app: web-server
  endpoints:
  - port: http
    path: /nginx-status
    interval: 30s
    scrapeTimeout: 10s
  namespaceSelector:
    matchNames:
    - web-volume-demo